# 开发指南

<cite>
**本文档引用的文件**  
- [README.md](file://README.md)
- [debug-env.js](file://debug-env.js)
- [debug-protobuf.js](file://debug-protobuf.js)
- [test-multicast.js](file://test-multicast.js)
- [test-protobuf-multicast.js](file://test-protobuf-multicast.js)
- [src/protobuf/PublicStruct.proto](file://src/protobuf/PublicStruct.proto)
- [src/protobuf/UavFlyStatusStruct.proto](file://src/protobuf/UavFlyStatusStruct.proto)
- [src/protobuf/UavNavMonitorStruct.proto](file://src/protobuf/UavNavMonitorStruct.proto)
- [src/protobuf/PlatformCmd.proto](file://src/protobuf/PlatformCmd.proto) - *最近提交中新增*
- [src/protobuf/PlatformStatus.proto](file://src/protobuf/PlatformStatus.proto) - *最近提交中新增*
- [src/main/services/multicast.service.ts](file://src/main/services/multicast.service.ts)
- [src/main/services/protobuf-parser.service.ts](file://src/main/services/protobuf-parser.service.ts)
- [src/main/services/multicast-sender.service.ts](file://src/main/services/multicast-sender.service.ts) - *最近提交中新增*
- [src/main/main.ts](file://src/main/main.ts)
- [src/main/database/db.service.ts](file://src/main/database/db.service.ts)
- [src/main/database/migrations/001-initial-schema.js](file://src/main/database/migrations/001-initial-schema.js)
- [src/main/database/migrations/002-update-table-users.js](file://src/main/database/migrations/002-update-table-users.js)
- [src/main/database/seeds/001-sample-data.js](file://src/main/database/seeds/001-sample-data.js)
- [src/renderer/views/pages/ArtilleryOperationPage.vue](file://src/renderer/views/pages/ArtilleryOperationPage.vue) - *最近提交中更新*
- [src/testScipt/test-platform-cmd.js](file://src/testScipt/test-platform-cmd.js) - *最近提交中新增*
- [src/testScipt/test-platform-status.js](file://src/testScipt/test-platform-status.js) - *最近提交中新增*
- [platform-speed-to-ground-speed-conversion.md](file://platform-speed-to-ground-speed-conversion.md) - *最近提交中添加*
- [docs/SPEED_SETTING_FEATURE.md](file://docs/SPEED_SETTING_FEATURE.md) - *最近提交中添加*
- [testScipt/test-platform-speed-waypoint.js](file://testScipt/test-platform-speed-waypoint.js) - *最近提交中添加*
- [src/main/services/multicast-sender.service.ts](file://src/main/services/multicast-sender.service.ts) - *最近提交中更新*
- [src/protobuf/PlatformCmd.proto](file://src/protobuf/PlatformCmd.proto) - *最近提交中更新*
- [src/protobuf/UaviationSimulationStruct.proto](file://src/protobuf/UaviationSimulationStruct.proto) - *最近提交中更新*
</cite>

## 更新摘要
**变更内容**   
- 新增了关于速度转换功能的详细文档，包括`platform-speed-to-ground-speed-conversion.md`中的实现细节
- 添加了无人机速度设置功能的完整说明，涵盖前端界面、数据结构和后端支持
- 更新了`test-platform-speed-waypoint.js`测试脚本的文档，详细说明了航点转换逻辑的修改
- 在"新增Protobuf协议流程"章节中补充了`Uav_Set_Speed`命令的实现细节
- 增强了`multicast-sender.service.ts`中速度相关字段的处理逻辑说明
- 更新了"测试脚本详解"章节，增加了速度相关测试脚本的运行方法和预期输出

## 目录
1. [本地开发与调试环境设置](#本地开发与调试环境设置)  
2. [调试工具使用指南](#调试工具使用指南)  
3. [测试脚本详解](#测试脚本详解)  
4. [断点调试与Chrome DevTools使用](#断点调试与chrome-devtools使用)  
5. [新增Protobuf协议流程](#新增protobuf协议流程)  
6. [数据库迁移脚本标准流程](#数据库迁移脚本标准流程)  
7. [代码风格与提交规范](#代码风格与提交规范)  

## 本地开发与调试环境设置

本项目基于Electron + Vue 3 + Vite + TypeScript构建，支持跨平台运行。开发者需确保本地环境满足以下要求：

- **Node.js**: 18+（推荐LTS版本）
- **包管理器**: npm 9+ 或 pnpm
- **Python**: 3.10+（用于node-gyp编译原生模块）
- **构建工具**:
  - **Windows**: Visual Studio Build Tools
  - **macOS**: Xcode Command Line Tools
  - **Linux**: build-essential

### 开发环境搭建步骤

1. **克隆项目**
   ```bash
   git clone <repository-url>
   cd afs-opEnd
   ```

2. **安装依赖**
   ```bash
   # 使用npm
   npm install
   
   # 或使用pnpm（推荐）
   pnpm install
   ```

3. **启动开发服务器**
   ```bash
   # 启动Electron主进程和Vite开发服务器
   npm run dev
   ```

4. **构建生产版本**
   ```bash
   # 构建可执行程序
   npm run build
   ```

5. **启动应用**
   ```bash
   # 启动已构建的应用
   npm start
   ```

**Section sources**
- [README.md](file://README.md#L0-L50)

## 调试工具使用指南

项目提供了两个专用的调试脚本，用于在不启动完整应用的情况下验证核心功能。

### debug-env.js：环境变量调试

该脚本用于验证`config.env`文件的加载和解析情况。

```javascript
// debug-env.js
const { app } = require('electron');
const dotenv = require('dotenv');
const path = require('path');

console.log('=== 主进程环境变量调试 ===');

const envPath = path.join(__dirname, 'config.env');
const fs = require('fs');

if (fs.existsSync(envPath)) {
  console.log('✅ config.env文件存在:', envPath);
  const envContent = fs.readFileSync(envPath, 'utf8');
  console.log('文件内容:\n', envContent);
  
  dotenv.config({ path: envPath });
  
  console.log('\n环境变量:');
  console.log('MULTICAST_ADDRESS:', process.env.MULTICAST_ADDRESS);
  console.log('MULTICAST_PORT:', process.env.MULTICAST_PORT);
  console.log('INTERFACE_ADDRESS:', process.env.INTERFACE_ADDRESS);
  console.log('NODE_ENV:', process.env.NODE_ENV);
  
  const config = {
    address: process.env.MULTICAST_ADDRESS || '224.0.0.1',
    port: parseInt(process.env.MULTICAST_PORT || '8888'),
    interfaceAddress: process.env.INTERFACE_ADDRESS || '0.0.0.0'
  };
  
  console.log('\ngetConfig返回值:', config);
} else {
  console.log('❌ config.env文件不存在:', envPath);
}

console.log('=========================='); 
```

**用途**：  
- 确认`config.env`文件路径正确且可读
- 验证环境变量是否被正确加载
- 模拟主进程中配置的获取逻辑

**运行方法**：
```bash
node debug-env.js
```

预期输出将显示`config.env`文件内容及解析后的环境变量值。

### debug-protobuf.js：Protobuf解析调试

该脚本用于独立测试Protobuf消息的加载和解析功能。

```javascript
// debug-protobuf.js
const protobuf = require('protobufjs');
const path = require('path');

async function debugProtobuf() {
  try {
    console.log('加载protobuf定义...');
    
    const root = await protobuf.load([
      path.join(__dirname, 'src/protobuf/PublicStruct.proto'),
      path.join(__dirname, 'src/protobuf/PlatFormStatus.proto')
    ]);
    
    console.log('✅ Protobuf定义加载成功');
    console.log('可用的类型:', Object.keys(root.nested || {}));
    
    const fullPacket = 'aa5501292200000008e90710041a1b0947688f1ec6195d4011a772f334b7f3434019ec75870b56e35840';
    const protobufHex = fullPacket.substring(16);
    const protobufData = Buffer.from(protobufHex, 'hex');
    
    console.log('原始数据包:', fullPacket);
    console.log('Protobuf数据:', protobufHex);
    console.log('Protobuf数据长度:', protobufData.length);
    
    try {
      const PlatformStatusInfo = root.lookupType('PlatformStatus.PlatformStatusInfo');
      console.log('✅ 找到PlatformStatusInfo类型');
      
      const decoded = PlatformStatusInfo.decode(protobufData);
      console.log('✅ 解码成功:', JSON.stringify(decoded, null, 2));
      
    } catch (error) {
      console.error('❌ 解码失败:', error.message);
    }
    
  } catch (error) {
    console.error('❌ 调试失败:', error);
  }
}

debugProtobuf();
```

**用途**：  
- 验证`.proto`文件路径是否正确
- 测试特定数据包的解析逻辑
- 调试`PlatformStatusInfo`等消息类型的定义

**运行方法**：
```bash
node debug-protobuf.js
```

**Section sources**
- [debug-env.js](file://debug-env.js#L0-L42)
- [debug-protobuf.js](file://debug-protobuf.js#L0-L42)

## 测试脚本详解

项目提供多个测试脚本，用于模拟不同场景下的数据发送。

### test-multicast.js：组播功能测试

此脚本创建一个UDP客户端，向指定组播地址周期性发送纯文本数据。

```javascript
// test-multicast.js
const dgram = require('dgram');
const sender = dgram.createSocket('udp4');

const MULTICAST_ADDRESS = '239.255.43.21';
const MULTICAST_PORT = 10086;

function sendTestData() {
  const message = Buffer.from(`测试数据 - ${new Date().toISOString()}`);
  
  sender.send(message, MULTICAST_PORT, MULTICAST_ADDRESS, (err) => {
    if (err) {
      console.error('发送失败:', err);
    } else {
      console.log(`已发送数据到 ${MULTICAST_ADDRESS}:${MULTICAST_PORT}:`, message.toString());
    }
  });
}

console.log('开始发送组播测试数据...');
console.log(`目标地址: ${MULTICAST_ADDRESS}:${MULTICAST_PORT}`);
console.log('按 Ctrl+C 停止');

setInterval(sendTestData, 5000);
sendTestData(); // 立即发送一次
```

**覆盖的测试用例**：  
- UDP组播套接字的创建与绑定
- 数据包的周期性发送
- 错误处理与优雅退出

**运行方法**：
```bash
node test-multicast.js
```

**预期输出**：
```
开始发送组播测试数据...
目标地址: 239.255.43.21:10086
按 Ctrl+C 停止
已发送数据到 239.255.43.21:10086: 测试数据 - 2024-05-20T08:30:00.000Z
```

### test-protobuf-multicast.js：Protobuf组播测试

此脚本是核心测试工具，用于发送符合协议格式的Protobuf数据包。

```javascript
// test-protobuf-multicast.js
const dgram = require('dgram');
const protobuf = require('protobufjs');
const path = require('path');

const sender = dgram.createSocket('udp4');
const MULTICAST_ADDRESS = '239.255.43.21';
const MULTICAST_PORT = 10086;

async function loadProtobufDefinitions() {
  // 加载多个.proto文件
  root = await protobuf.load([
    path.join(__dirname, 'src', 'protobuf', 'PublicStruct.proto'),
    path.join(__dirname, 'src', 'protobuf', 'UavNavMonitorStruct.proto'),
    path.join(__dirname, 'src', 'protobuf', 'UavFlyMonitorStruct.proto'),
    path.join(__dirname, 'src', 'protobuf', 'UaviationSimulationStruct.proto')
  ]);
}

// 创建不同类型的数据包
function createHeartbeatData() { /* ... */ }
function createFlyStatusData() { /* ... */ }
function createFlyControlData() { /* ... */ }
function createAttitudeControlData() { /* ... */ }
function createEngineControlData() { /* ... */ }

function sendData(data, description) {
  sender.send(data, MULTICAST_PORT, MULTICAST_ADDRESS, (err) => {
    if (err) {
      console.error('发送失败:', err);
    } else {
      console.log(`已发送 ${description} 到 ${MULTICAST_ADDRESS}:${MULTICAST_PORT}`);
      console.log(`数据大小: ${data.length} 字节`);
      console.log(`包类型: 0x${data[0].toString(16)}`);
      console.log('---');
    }
  });
}

async function main() {
  await loadProtobufDefinitions();
  
  console.log('开始发送Protobuf格式的组播测试数据...');
  console.log(`目标地址: ${MULTICAST_ADDRESS}:${MULTICAST_PORT}`);
  console.log('按 Ctrl+C 停止');
  console.log('---');

  // 立即发送一次各种类型的数据
  sendData(createHeartbeatData(), '心跳数据');
  setTimeout(() => sendData(createFlyStatusData(), '飞行状态数据'), 1000);
  setTimeout(() => sendData(createFlyControlData(), '飞行控制数据'), 2000);
  setTimeout(() => sendData(createAttitudeControlData(), '姿态控制数据'), 3000);
  setTimeout(() => sendData(createEngineControlData(), '发动机控制数据'), 4000);

  // 周期性发送
  setInterval(() => sendData(createHeartbeatData(), '心跳数据'), 10000);
  setInterval(() => sendData(createFlyStatusData(), '飞行状态数据'), 15000);
}
```

**覆盖的测试用例范围**：  
- Protobuf定义文件的批量加载
- 多种消息类型（心跳、飞行状态、控制指令等）的序列化
- 符合`0xAA 0x55 + ProtocolID + PackageType + Size + ProtobufData`格式的数据包构造
- 周期性与一次性数据发送的混合场景

**运行方法**：
```bash
node test-protobuf-multicast.js
```

**预期输出**：
```
开始发送Protobuf格式的组播测试数据...
目标地址: 239.255.43.21:10086
按 Ctrl+C 停止
---
已发送 心跳数据 到 239.255.43.21:10086
数据大小: 5 字节
包类型: 0x2
---
已发送 飞行状态数据 到 239.255.43.21:10086
数据大小: 150 字节
包类型: 0x1
---
```

### test-platform-cmd.js：PlatformCmd协议测试

此脚本用于发送符合PlatformCmd协议格式的组播数据包，主要用于测试火炮控制命令的发送功能。

```javascript
// src/testScipt/test-platform-cmd.js
const dgram = require('dgram');
const protobuf = require('protobufjs');
const path = require('path');

// 创建UDP socket用于发送组播数据
const sender = dgram.createSocket('udp4');

// 组播地址和端口
const MULTICAST_ADDRESS = '239.255.43.21';
const MULTICAST_PORT = 10086;

// 加载protobuf定义
let root = null;
let messageTypes = {};

async function loadProtobufDefinitions() {
  try {
    const protobufPath = path.join(__dirname, '..', 'protobuf');
    
    // 加载PlatformCmd相关的protobuf定义
    root = await protobuf.load([
      path.join(protobufPath, 'PublicStruct.proto'),
      path.join(protobufPath, 'PlatformCmd.proto')
    ]);

    // 获取消息类型
    messageTypes = {
      PlatformCmd: root.lookupType('PlatformStatus.PlatformCmd'),
      FireParam: root.lookupType('PlatformStatus.FireParam')
    };

    console.log('PlatformCmd Protobuf定义文件加载成功');
    console.log('可用消息类型:', Object.keys(messageTypes));
  } catch (error) {
    console.error('加载PlatformCmd Protobuf定义文件失败:', error);
    process.exit(1);
  }
}

// 创建PlatformCmd测试数据
function createPlatformCmdData() {
  // 创建火炮发射参数
  const fireParam = messageTypes.FireParam.create({
    weaponName: '155毫米榴弹炮',
    targetName: '敌方装甲车',
    quantity: 1
  });

  // 创建平台控制命令
  const platformCmd = messageTypes.PlatformCmd.create({
    commandID: Date.now(),
    platformName: 'artillery1',
    platformType: 'Artillery',
    command: 10, // Arty_Fire = 10
    fireParam: fireParam
  });

  return platformCmd;
}

// 创建带协议头的数据包
function createPlatformCmdPacket() {
  try {
    const platformCmdData = createPlatformCmdData();
    
    // 编码protobuf数据
    const protobufBuffer = messageTypes.PlatformCmd.encode(platformCmdData).finish();
    
    console.log('创建的PlatformCmd数据:', JSON.stringify(messageTypes.PlatformCmd.toObject(platformCmdData), null, 2));
    console.log('Protobuf编码后大小:', protobufBuffer.length, '字节');

    // 构造完整的数据包: 0xAA 0x55 + protocolID + packageType + size + protobufData
    const protocolID = 0x01; // 协议ID
    const packageType = 0x2A; // PackType_PlatformCmd
    const size = protobufBuffer.length;

    // 创建包头
    const header = Buffer.alloc(8);
    header[0] = 0xAA; // 包头标识
    header[1] = 0x55; // 包头标识
    header[2] = protocolID; // 协议ID
    header[3] = packageType; // 包类型
    header.writeUInt32LE(size, 4); // protobuf数据长度（小端序）

    // 组合完整数据包
    const fullPacket = Buffer.concat([header, protobufBuffer]);
    
    console.log('数据包构造详情:', {
      总长度: fullPacket.length,
      包头: header.toString('hex'),
      协议ID: `0x${protocolID.toString(16)}`,
      包类型: `0x${packageType.toString(16)}`,
      声明大小: size,
      实际protobuf大小: protobufBuffer.length,
      完整包前16字节: fullPacket.subarray(0, Math.min(16, fullPacket.length)).toString('hex')
    });

    return fullPacket;
  } catch (error) {
    console.error('创建PlatformCmd数据包失败:', error);
    throw error;
  }
}

// 发送数据
function sendPlatformCmdData() {
  try {
    const packet = createPlatformCmdPacket();
    
    sender.send(packet, MULTICAST_PORT, MULTICAST_ADDRESS, (err) => {
      if (err) {
        console.error('发送失败:', err);
      } else {
        console.log(`✅ 已发送PlatformCmd数据到 ${MULTICAST_ADDRESS}:${MULTICAST_PORT}`);
        console.log(`📦 数据包大小: ${packet.length} 字节`);
        console.log(`📋 包类型: 0x${packet[3].toString(16)} (PackType_PlatformCmd)`);
        console.log(`🔗 协议ID: 0x${packet[2].toString(16)}`);
        console.log(`⏰ 发送时间: ${new Date().toLocaleString('zh-CN')}`);
        console.log('---');
      }
    });
  } catch (error) {
    console.error('发送PlatformCmd数据失败:', error);
  }
}

// 主函数
async function main() {
  await loadProtobufDefinitions();
  
  console.log('🚀 开始发送PlatformCmd格式的组播测试数据...');
  console.log(`🎯 目标地址: ${MULTICAST_ADDRESS}:${MULTICAST_PORT}`);
  console.log('⏹️  按 Ctrl+C 停止');
  console.log('=====================================');

  // 立即发送一次
  console.log('📤 发送PlatformCmd测试数据...');
  sendPlatformCmdData();

  // 每10秒发送一次
  setInterval(() => {
    console.log('📤 定时发送PlatformCmd数据...');
    sendPlatformCmdData();
  }, 10000);
}

// 优雅退出
process.on('SIGINT', () => {
  console.log('\n🛑 停止发送...');
  sender.close();
  process.exit(0);
});

// 启动
main().catch(console.error);
```

**覆盖的测试用例范围**：  
- PlatformCmd.proto和PublicStruct.proto定义文件的加载
- PlatformCmd消息类型和FireParam子结构的序列化
- 符合`0xAA 0x55 + ProtocolID + PackageType + Size + ProtobufData`格式的数据包构造
- 火炮发射命令（Arty_Fire = 10）的测试
- 周期性发送PlatformCmd数据包

**运行方法**：
```bash
node src/testScipt/test-platform-cmd.js
```

**预期输出**：
```
🚀 开始发送PlatformCmd格式的组播测试数据...
🎯 目标地址: 239.255.43.21:10086
⏹️  按 Ctrl+C 停止
=====================================
📤 发送PlatformCmd测试数据...
创建的PlatformCmd数据: {
  "commandID": 1756871426494,
  "platformName": "artillery1",
  "platformType": "Artillery",
  "command": 10,
  "fireParam": {
    "weaponName": "155毫米榴弹炮",
    "targetName": "敌方装甲车",
    "quantity": 1
  }
}
Protobuf编码后大小: 80 字节
数据包构造详情: {
  "总长度": 88,
  "包头": "aa55012a",
  "协议ID": "0x1",
  "包类型": "0x2a",
  "声明大小": 80,
  "实际protobuf大小": 80,
  "完整包前16字节": "aa55012a500000000a00000000000000"
}
✅ 已发送PlatformCmd数据到 239.255.43.21:10086
📦 数据包大小: 88 字节
📋 包类型: 0x2a (PackType_PlatformCmd)
🔗 协议ID: 0x1
⏰ 发送时间: 2025/9/3 14:30:26
---
```

### test-platform-status.js：PlatformStatus协议测试

此脚本用于发送符合PlatformStatus协议格式的组播数据包，主要用于测试平台状态信息的发送功能。

```javascript
// src/testScipt/test-platform-status.js
const dgram = require('dgram');
const protobuf = require('protobufjs');
const path = require('path');

// 创建UDP socket用于发送组播数据
const sender = dgram.createSocket('udp4');

// 组播地址和端口
const MULTICAST_ADDRESS = '239.255.43.21';
const MULTICAST_PORT = 10086;

// 加载protobuf定义
let root = null;
let messageTypes = {};

async function loadProtobufDefinitions() {
  try {
    const protobufPath = path.join(__dirname, '..', 'protobuf');
    
    // 加载Platform Status相关的protobuf定义
    root = await protobuf.load([
      path.join(protobufPath, 'PlatformStatus.proto')
    ]);

    // 获取消息类型
    messageTypes = {
      Platforms: root.lookupType('PlatformStatus.Platforms'),
      Platform: root.lookupType('PlatformStatus.Platform'),
      PlatformBase: root.lookupType('PlatformStatus.PlatformBase'),
      Location: root.lookupType('PlatformStatus.Location'),
      WayPoint: root.lookupType('PlatformStatus.WayPoint'),
      Mover: root.lookupType('PlatformStatus.Mover'),
      PartParam: root.lookupType('PlatformStatus.PartParam'),
      Comm: root.lookupType('PlatformStatus.Comm'),
      Sensor: root.lookupType('PlatformStatus.Sensor'),
      Weapon: root.lookupType('PlatformStatus.Weapon'),
      Track: root.lookupType('PlatformStatus.Track')
    };

    console.log('PlatformStatus Protobuf定义文件加载成功');
    console.log('可用消息类型:', Object.keys(messageTypes));
  } catch (error) {
    console.error('加载PlatformStatus Protobuf定义文件失败:', error);
    process.exit(1);
  }
}

// 创建位置信息
function createLocation(longitude, latitude, altitude) {
  return {
    longitude: longitude,
    latitude: latitude,
    altitude: altitude
  };
}

// 创建航迹点
function createWayPoint(longitude, latitude, altitude, labelName, speed) {
  return {
    longitude: longitude,
    latitude: latitude,
    altitude: altitude,
    labelName: labelName || "",
    speed: speed || 0
  };
}

// 创建推进器信息
function createMover(type, wayPoints) {
  return {
    type: type,
    route: wayPoints || []
  };
}

// 创建部件参数
function createPartParam(name, type, slewMode, minAzSlew, maxAzSlew, minElSlew, maxElSlew, currentAz, currentEl, isTurnedOn) {
  return {
    name: name,
    type: type,
    slewMode: slewMode || 0, // cSLEW_FIXED
    minAzSlew: minAzSlew || 0,
    maxAzSlew: maxAzSlew || 360,
    minElSlew: minElSlew || -90,
    maxElSlew: maxElSlew || 90,
    currentAz: currentAz || 0,
    currentEl: currentEl || 0,
    isTurnedOn: isTurnedOn || false
  };
}

// 创建通信设备
function createComm(name, type, network) {
  return {
    base: createPartParam(name, type, 0, 0, 360, -90, 90, 0, 0, true),
    network: network || "Radio"
  };
}

// 创建传感器
function createSensor(name, type, mode) {
  return {
    base: createPartParam(name, type, 3, 0, 360, -90, 90, 45, 30, true), // cSLEW_AZ_EL
    mode: mode || "Search"
  };
}

// 创建武器
function createWeapon(name, type, quantity) {
  return {
    base: createPartParam(name, type, 1, 0, 180, -10, 80, 0, 0, false), // cSLEW_AZ
    quantity: quantity || 0
  };
}

// 创建跟踪目标
function createTrack(sensorName, targetName, targetType) {
  return {
    sensorName: sensorName,
    targetName: targetName,
    targetType: targetType
  };
}

// 创建平台基础信息
function createPlatformBase(name, type, side, group, broken, location) {
  return {
    name: name,
    type: type,
    side: side,
    group: group,
    broken: broken || false,
    location: location
  };
}

// 创建单个平台数据
function createPlatform(platformId, name, type) {
  const location = createLocation(116.3974 + Math.random() * 0.01, 39.9093 + Math.random() * 0.01, 1000 + Math.random() * 500);
  
  const base = createPlatformBase(
    name,
    type,
    "友军",
    "第一编队",
    false,
    location
  );

  // 创建航迹点
  const wayPoints = [
    createWayPoint(116.3974, 39.9093, 1000, "起始点", 50),
    createWayPoint(116.4074, 39.9193, 1200, "航迹点1", 80),
    createWayPoint(116.4174, 39.9293, 1500, "目标点", 60)
  ];

  const mover = createMover("Jet Engine", wayPoints);

  // 通信设备
  const comms = [
    createComm("主通信", "UHF Radio", "UHF"),
    createComm("数据链", "Data Link", "LINK16")
  ];

  // 传感器
  const sensors = [
    createSensor("主雷达", "Search Radar", "Search"),
    createSensor("光电系统", "EO/IR", "Track")
  ];

  // 武器
  const weapons = [
    createWeapon("空空导弹", "AAM", 4),
    createWeapon("机炮", "Gun", 200)
  ];

  // 跟踪目标
  const tracks = [
    createTrack("主雷达", "敌机001", "Fighter"),
    createTrack("光电系统", "敌机002", "Bomber")
  ];

  return {
    base: base,
    updataTime: Date.now() / 1000, // 当前时间戳（秒）
    mover: mover,
    comms: comms,
    sensors: sensors,
    weapons: weapons,
    tracks: tracks
  };
}

// 创建多平台状态数据
function createPlatformsData() {
  const platforms = [
    createPlatform(1, "战斗机-001", "Fighter"),
    createPlatform(2, "轰炸机-001", "Bomber"),
    createPlatform(3, "预警机-001", "AWACS"),
    createPlatform(4, "运输机-001", "Transport")
  ];

  const platformsData = {
    platform: platforms
  };

  return platformsData;
}

// 创建带协议头的数据包
function createPlatformStatusPacket() {
  try {
    const platformsData = createPlatformsData();
    
    // 编码protobuf数据
    const message = messageTypes.Platforms.create(platformsData);
    const protobufBuffer = messageTypes.Platforms.encode(message).finish();
    
    console.log('创建的平台数据:', JSON.stringify(platformsData, null, 2));
    console.log('Protobuf编码后大小:', protobufBuffer.length, '字节');

    // 构造完整的数据包: 0xAA 0x55 + protocolID + packageType + size + protobufData
    const protocolID = 0x01; // 协议ID
    const packageType = 0x29; // PackType_PlatformStatus
    const size = protobufBuffer.length;

    // 创建包头
    const header = Buffer.alloc(8);
    header[0] = 0xAA; // 包头标识
    header[1] = 0x55; // 包头标识
    header[2] = protocolID; // 协议ID
    header[3] = packageType; // 包类型
    header.writeUInt32LE(size, 4); // protobuf数据长度（小端序）

    // 组合完整数据包
    const fullPacket = Buffer.concat([header, protobufBuffer]);
    
    console.log('数据包构造详情:', {
      总长度: fullPacket.length,
      包头: header.toString('hex'),
      协议ID: `0x${protocolID.toString(16)}`,
      包类型: `0x${packageType.toString(16)}`,
      声明大小: size,
      实际protobuf大小: protobufBuffer.length,
      完整包前16字节: fullPacket.subarray(0, Math.min(16, fullPacket.length)).toString('hex')
    });

    return fullPacket;
  } catch (error) {
    console.error('创建平台状态数据包失败:', error);
    throw error;
  }
}

// 发送数据
function sendPlatformStatusData() {
  try {
    const packet = createPlatformStatusPacket();
    
    sender.send(packet, MULTICAST_PORT, MULTICAST_ADDRESS, (err) => {
      if (err) {
        console.error('发送失败:', err);
      } else {
        console.log(`✅ 已发送平台状态数据到 ${MULTICAST_ADDRESS}:${MULTICAST_PORT}`);
        console.log(`📦 数据包大小: ${packet.length} 字节`);
        console.log(`📋 包类型: 0x${packet[3].toString(16)} (PackType_PlatformStatus)`);
        console.log(`🔗 协议ID: 0x${packet[2].toString(16)}`);
        console.log(`⏰ 发送时间: ${new Date().toLocaleString('zh-CN')}`);
        console.log('---');
      }
    });
  } catch (error) {
    console.error('发送平台状态数据失败:', error);
  }
}

// 创建简化的单平台测试数据
function createSimplePlatformData() {
  const simplePlatform = {
    base: {
      name: "测试平台-001",
      type: "Fighter",
      side: "友军",
      group: "测试组",
      broken: false,
      location: {
        longitude: 116.3974,
        latitude: 39.9093,
        altitude: 1000
      }
    },
    updataTime: Date.now() / 1000
  };

  const platformsData = {
    platform: [simplePlatform]
  };

  return platformsData;
}

// 发送简化测试数据
function sendSimplePlatformData() {
  try {
    const platformsData = createSimplePlatformData();
    
    // 编码protobuf数据
    const message = messageTypes.Platforms.create(platformsData);
    const protobufBuffer = messageTypes.Platforms.encode(message).finish();
    
    console.log('创建的简化平台数据:', JSON.stringify(platformsData, null, 2));

    // 构造完整的数据包
    const protocolID = 0x01;
    const packageType = 0x29;
    const size = protobufBuffer.length;

    const header = Buffer.alloc(8);
    header[0] = 0xAA;
    header[1] = 0x55;
    header[2] = protocolID;
    header[3] = packageType;
    header.writeUInt32LE(size, 4);

    const fullPacket = Buffer.concat([header, protobufBuffer]);
    
    sender.send(fullPacket, MULTICAST_PORT, MULTICAST_ADDRESS, (err) => {
      if (err) {
        console.error('发送简化平台数据失败:', err);
      } else {
        console.log(`✅ 已发送简化平台状态数据到 ${MULTICAST_ADDRESS}:${MULTICAST_PORT}`);
        console.log(`📦 数据包大小: ${fullPacket.length} 字节`);
        console.log(`📋 包类型: 0x${fullPacket[3].toString(16)} (PackType_PlatformStatus)`);
        console.log('---');
      }
    });
  } catch (error) {
    console.error('发送简化平台数据失败:', error);
  }
}

// 主函数
async function main() {
  await loadProtobufDefinitions();
  
  console.log('🚀 开始发送PlatformStatus格式的组播测试数据...');
  console.log(`🎯 目标地址: ${MULTICAST_ADDRESS}:${MULTICAST_PORT}`);
  console.log('⏹️  按 Ctrl+C 停止');
  console.log('=====================================');

  // 立即发送一次完整平台状态数据
  console.log('📤 发送完整平台状态数据...');
  sendPlatformStatusData();

  // 每30秒发送一次完整数据
  setInterval(() => {
    console.log('📤 定时发送完整平台状态数据...');
    sendPlatformStatusData();
  }, 30000);

  // 每10秒发送一次简化平台状态数据
  setInterval(() => {
    console.log('📤 发送简化平台状态数据...');
    sendSimplePlatformData();
  }, 10000);
}

// 优雅退出
process.on('SIGINT', () => {
  console.log('\n🛑 停止发送...');
  sender.close();
  process.exit(0);
});

// 启动
main().catch(console.error);
```

**覆盖的测试用例范围**：  
- PlatformStatus.proto定义文件的加载
- Platforms、Platform、PlatformBase等消息类型的序列化
- 多平台状态信息的模拟（战斗机、轰炸机、预警机、运输机）
- 详细设备信息的测试（通信设备、传感器、武器、跟踪目标、航迹点）
- 符合`0xAA 0x55 + ProtocolID + PackageType + Size + ProtobufData`格式的数据包构造
- 周期性发送完整和简化平台状态数据

**运行方法**：
```bash
node src/testScipt/test-platform-status.js
```

**预期输出**：
```
🚀 开始发送PlatformStatus格式的组播测试数据...
🎯 目标地址: 239.255.43.21:10086
⏹️  按 Ctrl+C 停止
=====================================
📤 发送完整平台状态数据...
创建的平台数据: {
  "platform": [
    {
      "base": {
        "name": "战斗机-001",
        "type": "Fighter",
        "side": "友军",
        "group": "第一编队",
        "broken": false,
        "location": {
          "longitude": 116.3984,
          "latitude": 39.9103,
          "altitude": 1234.5
        }
      },
      "updataTime": 1756871426.494,
      "mover": {
        "type": "Jet Engine",
        "route": [
          {
            "longitude": 116.3974,
            "latitude": 39.9093,
            "altitude": 1000,
            "labelName": "起始点",
            "speed": 50
          },
          // ... 其他航迹点
        ]
      },
      "comms": [
        {
          "base": {
            "name": "主通信",
            "type": "UHF Radio",
            "slewMode": 0,
            "minAzSlew": 0,
            "maxAzSlew": 360,
            "minElSlew": -90,
            "maxElSlew": 90,
            "currentAz": 0,
            "currentEl": 0,
            "isTurnedOn": true
          },
          "network": "UHF"
        },
        // ... 其他通信设备
      ],
      "sensors": [
        {
          "base": {
            "name": "主雷达",
            "type": "Search Radar",
            "slewMode": 3,
            "minAzSlew": 0,
            "maxAzSlew": 360,
            "minElSlew": -90,
            "maxElSlew": 90,
            "currentAz": 45,
            "currentEl": 30,
            "isTurnedOn": true
          },
          "mode": "Search"
        },
        // ... 其他传感器
      ],
      "weapons": [
        {
          "base": {
            "name": "空空导弹",
            "type": "AAM",
            "slewMode": 1,
            "minAzSlew": 0,
            "maxAzSlew": 180,
            "minElSlew": -10,
            "maxElSlew": 80,
            "currentAz": 0,
            "currentEl": 0,
            "isTurnedOn": false
          },
          "quantity": 4
        },
        // ... 其他武器
      ],
      "tracks": [
        {
          "sensorName": "主雷达",
          "targetName": "敌机001",
          "targetType": "Fighter"
        },
        // ... 其他跟踪目标
      ]
    },
    // ... 其他3个平台
  ]
}
Protobuf编码后大小: 3403 字节
数据包构造详情: {
  "总长度": 3411,
  "包头": "aa550129",
  "协议ID": "0x1",
  "包类型": "0x29",
  "声明大小": 3403,
  "实际protobuf大小": 3403,
  "完整包前16字节": "aa550129fb0d00000a00000000000000"
}
✅ 已发送平台状态数据到 239.255.43.21:10086
📦 数据包大小: 3411 字节
📋 包类型: 0x29 (PackType_PlatformStatus)
🔗 协议ID: 0x1
⏰ 发送时间: 2025/9/3 14:30:26
---
```

### test-platform-speed-waypoint.js：航点速度转换测试

此脚本用于验证航点转换时使用平台速度的功能，确保航点速度与平台实际速度保持一致。

```javascript
// testScipt/test-platform-speed-waypoint.js
console.log('🛩️ 航点转换使用平台速度功能验证');
console.log('=================================');

console.log('\n🎯 修改目标:');
console.log('- 航点转换时不再使用固定的默认速度10');
console.log('- 获取当前选择平台的速度数据');
console.log('- 将平台速度设置为各航点的速度');

console.log('\n🔧 修改内容:');

console.log('\n1. IPC通信修改:');
console.log('   修改前:');
console.log('   ```javascript');
console.log('   // 请求平台名称');
console.log('   window.webContents.send("route:requestSelectedPlatform");');
console.log('   // 响应平台名称');
console.log('   resolve(platformName);');
console.log('   ```');
console.log('   ');
console.log('   修改后:');
console.log('   ```javascript');
console.log('   // 请求平台数据');
console.log('   window.webContents.send("route:requestSelectedPlatformData");');
console.log('   // 响应平台数据');
console.log('   resolve({name: platformName, speed: platformSpeed});');
console.log('   ```');

console.log('\n2. 航点转换逻辑修改:');
console.log('   修改前:');
console.log('   ```javascript');
console.log('   return {');
console.log('     longitude: coord.longitude || 0,');
console.log('     latitude: coord.latitude || 0,');
console.log('     altitude: coord.altitude || 0,');
console.log('     labelName: `航点${index + 1}`,');
console.log('     speed: 10 // 固定默认速度');
console.log('   };');
console.log('   ```');
console.log('   ');
console.log('   修改后:');
console.log('   ```javascript');
console.log('   const platformSpeed = selectedPlatformData.speed || 10;');
console.log('   return {');
console.log('     longitude: coord.longitude || 0,');
console.log('     latitude: coord.latitude || 0,');
console.log('     altitude: coord.altitude || 0,');
console.log('     labelName: `航点${index + 1}`,');
console.log('     speed: platformSpeed // 使用平台速度');
console.log('   };');
console.log('   ```');

console.log('\n3. 前端响应逻辑:');
console.log('   ```javascript');
console.log('   // 获取当前选择平台的完整数据');
console.log('   const currentPlatform = platforms.value.find(p => p.name === selectedPlatform.value);');
console.log('   const platformData = {');
console.log('     name: selectedPlatform.value || "",');
console.log('     speed: currentPlatform?.base?.speed || undefined');
console.log('   };');
console.log('   ```');

console.log('\n📊 数据流程:');

console.log('\n   🔄 完整流程:');
console.log('   1. 导航软件发送航线数据 (UavRouteUpload)');
console.log('   2. 系统接收并验证UavId匹配');
console.log('   3. 请求当前选择的平台数据 (包含速度)');
console.log('   4. CommandTestPage响应平台数据');
console.log('   5. 使用平台速度转换航点');
console.log('   6. 发送PlatformCmd给平台');

console.log('\n   📡 平台数据结构:');
console.log('   ```javascript');
console.log('   {');
console.log('     name: "UAV-001",           // 平台名称');
console.log('     speed: 25                  // 平台当前速度 (m/s)');
console.log('   }');
console.log('   ```');

console.log('\n   🗺️ 转换后的航点:');
console.log('   ```javascript');
console.log('   [');
console.log('     {');
console.log('       longitude: 116.3974,');
console.log('       latitude: 39.9093,');
console.log('       altitude: 100,');
console.log('       labelName: "航点1",');
console.log('       speed: 25              // 使用平台速度而不是10');
console.log('     },');
console.log('     // ... 更多航点');
console.log('   ]');
console.log('   ```');

console.log('\n🧪 测试场景:');

console.log('\n   📊 场景1: 平台有速度数据');
console.log('   前提条件:');
console.log('   - 已选择平台 (如: UAV-001)');
console.log('   - 平台状态数据中包含速度信息 (如: 25 m/s)');
console.log('   测试步骤:');
console.log('   1. 发送航线数据包');
console.log('   2. 观察转换后的航点速度');
console.log('   预期结果: 所有航点速度为25 m/s');

console.log('\n   🔄 场景2: 平台无速度数据');
console.log('   前提条件:');
console.log('   - 已选择平台但速度数据为空或undefined');
console.log('   测试步骤:');
console.log('   1. 发送航线数据包');
console.log('   2. 观察转换后的航点速度');
console.log('   预期结果: 所有航点速度为默认值10 m/s');

console.log('\n   ❌ 场景3: 未选择平台');
console.log('   前提条件:');
console.log('   - 未选择任何平台');
console.log('   测试步骤:');
console.log('   1. 发送航线数据包');
console.log('   2. 观察系统响应');
console.log('   预期结果: 跳过转换，提示需要选择平台');

console.log('\n   🔍 场景4: 多个航点验证');
console.log('   前提条件:');
console.log('   - 选择速度为30 m/s的平台');
console.log('   - 发送包含5个航点的航线');
console.log('   测试步骤:');
console.log('   1. 发送多航点航线数据');
console.log('   2. 检查每个航点的速度设置');
console.log('   预期结果: 所有5个航点速度都为30 m/s');

console.log('\n📋 验证方法:');

console.log('\n   💻 控制台日志检查:');
console.log('   查找以下日志:');
console.log('   - "[RouteConverter] 使用选择的平台: UAV-001 速度: 25"');
console.log('   - "[RouteConverter] 使用平台速度: 25 m/s"');
console.log('   - "[CommandTestPage] 响应平台数据: {name: ..., speed: ...}"');

console.log('\n   📦 数据包内容验证:');
console.log('   1. 使用组播监听工具');
console.log('   2. 捕获转换后的PlatformCmd数据包');
console.log('   3. 检查navParam.route中每个航点的speed字段');
console.log('   4. 确认速度值与平台速度一致');

console.log('\n   🎛️ 界面操作验证:');
console.log('   1. 在CommandTestPage选择不同平台');
console.log('   2. 观察平台状态数据中的速度信息');
console.log('   3. 发送航线数据测试转换');
console.log('   4. 验证转换结果使用正确的速度');

console.log('\n✅ 成功标准:');
console.log('- 航点转换时正确获取平台速度数据');
console.log('- 所有航点使用平台速度而不是固定值10');
console.log('- 平台无速度数据时使用默认值10');
console.log('- 未选择平台时正确处理错误情况');
console.log('- IPC通信正常，数据传递准确');
console.log('- 控制台日志清晰显示使用的速度值');

console.log('\n🎯 功能优势:');
console.log('- 航点速度与平台实际速度保持一致');
console.log('- 提高航线规划的准确性');
console.log('- 减少手动设置速度的工作量');
console.log('- 支持动态速度调整');

console.log('\n🚀 开始测试平台速度航点转换功能！');
```

**覆盖的测试用例范围**：  
- IPC通信修改，从请求平台名称改为请求平台数据（包含速度）
- 航点转换逻辑修改，使用平台速度而非固定默认值10
- 前端响应逻辑更新，返回平台名称和速度信息
- 多种测试场景验证（有速度数据、无速度数据、未选择平台、多航点）
- 控制台日志、数据包内容和界面操作的验证方法

**运行方法**：
```bash
node testScipt/test-platform-speed-waypoint.js
```

**预期输出**：
```
🛩️ 航点转换使用平台速度功能验证
=================================

🎯 修改目标:
- 航点转换时不再使用固定的默认速度10
- 获取当前选择平台的速度数据
- 将平台速度设置为各航点的速度

🔧 修改内容:

1. IPC通信修改:
   修改前:
   ```javascript
   // 请求平台名称
   window.webContents.send("route:requestSelectedPlatform");
   // 响应平台名称
   resolve(platformName);
   ```

   修改后:
   ```javascript
   // 请求平台数据
   window.webContents.send("route:requestSelectedPlatformData");
   // 响应平台数据
   resolve({name: platformName, speed: platformSpeed});
   ```

2. 航点转换逻辑修改:
   修改前:
   ```javascript
   return {
     longitude: coord.longitude || 0,
     latitude: coord.latitude || 0,
     altitude: coord.altitude || 0,
     labelName: `航点${index + 1}`,
     speed: 10 // 固定默认速度
   };
   ```

   修改后:
   ```javascript
   const platformSpeed = selectedPlatformData.speed || 10;
   return {
     longitude: coord.longitude || 0,
     latitude: coord.latitude || 0,
     altitude: coord.altitude || 0,
     labelName: `航点${index + 1}`,
     speed: platformSpeed // 使用平台速度
   };
   ```

✅ 成功标准:
- 航点转换时正确获取平台速度数据
- 所有航点使用平台速度而不是固定值10
- 平台无速度数据时使用默认值10
- 未选择平台时正确处理错误情况
- IPC通信正常，数据传递准确
- 控制台日志清晰显示使用的速度值

🚀 开始测试平台速度航点转换功能！
```

**Section sources**
- [test-multicast.js](file://test-multicast.js#L0-L36)
- [test-protobuf-multicast.js](file://test-protobuf-multicast.js#L0-L230)
- [src/testScipt/test-platform-cmd.js](file://src/testScipt/test-platform-cmd.js#L0-L155) - *最近提交中新增*
- [src/testScipt/test-platform-status.js](file://src/testScipt/test-platform-status.js#L0-L381) - *最近提交中新增*
- [testScipt/test-platform-speed-waypoint.js](file://testScipt/test-platform-speed-waypoint.js#L0-L163) - *最近提交中添加*

## 断点调试与Chrome DevTools使用

### 主进程调试

主进程（Node.js环境）的调试主要通过`console.log`和`debugger`语句进行。

1. **在代码中设置断点**：
   ```typescript
   // src/main/main.ts
   ipcMain.handle("multicast:start", async () => {
     debugger; // 此处将暂停执行
     try {
       await multicastService.start();
       return { success: true };
     } catch (error: any) {
       return { success: false, error: error.message };
     }
   });
   ```

2. **启动调试**：
   - 在开发模式下运行 `npm run dev`
   - 打开Chrome浏览器，访问 `chrome://inspect`
   - 在"Remote Target"列表中找到Electron的Node.js进程，点击"inspect"链接
   - 此时将打开Chrome DevTools，可以查看调用栈、作用域变量等

### 渲染进程调试

渲染进程（Vue 3前端）的调试更为直观。

1. **打开开发者工具**：
   - **快捷键**：`Cmd+Option+I` (macOS) 或 `Ctrl+Shift+I` (Windows/Linux)
   - **菜单**：点击"开发" -> "打开开发者工具"

2. **在Vue组件中设置断点**：
   ```vue
   <!-- src/renderer/views/pages/MulticastPage.vue -->
   <script setup lang="ts">
   import { onMounted } from 'vue';
   
   onMounted(() => {
     debugger; // 页面加载时暂停
     window.electron.ipcRenderer.invoke('multicast:getStatus').then(status => {
       console.log('组播状态:', status);
     });
   });
   </script>
   ```

3. **使用DevTools功能**：
   - **Elements**: 检查和修改DOM结构
   - **Console**: 查看日志和执行JavaScript
   - **Sources**: 设置断点、单步执行
   - **Network**: 监控IPC通信
   - **Memory**: 分析内存使用情况

**Section sources**
- [src/main/main.ts](file://src/main/main.ts#L0-L449)
- [src/renderer/views/pages/MulticastPage.vue](file://src/renderer/views/pages/MulticastPage.vue)

## 新增Protobuf协议流程

当需要支持新的通信协议时，应遵循以下标准流程：

1. **创建新的`.proto`文件**  
   在`src/protobuf/`目录下创建新文件，例如`NewProtocol.proto`。

2. **定义消息结构**  
   遵循项目约定的命名和格式：
   ```proto
   // src/protobuf/NewProtocol.proto
   import "PublicStruct.proto";
   package NewModule;
   
   message NewMessage {
     required int32 uavID = 1;
     optional PublicStruct.GeoCoordinate coord = 2;
     // ... 其他字段
   }
   ```

3. **在`PublicStruct.proto`中添加包类型枚举**  
   ```proto
   enum PackageType {
     // ... 其他类型
     PackType_NewMessage = 0x30; // 分配新的包类型值
   }
   ```

4. **在`protobuf-parser.service.ts`中添加解析逻辑**  
   ```typescript
   // src/main/services/protobuf-parser.service.ts
   private parseNewMessage(data: Buffer): any {
     try {
       const NewMessage = this.root!.lookupType('NewModule.NewMessage');
       return NewMessage.decode(data);
     } catch (error) {
       console.error('解析新消息失败:', error);
       return { error: '解析失败', raw: data.toString('hex') };
     }
   }
   
   // 在parsePacket的switch语句中添加
   case 0x30: // PackType_NewMessage
     parsedData = this.parseNewMessage(messageData);
     break;
   ```

5. **更新`test-protobuf-multicast.js`以包含新消息的测试**  
   ```javascript
   function createNewMessageData() {
     // 构造测试数据
   }
   
   // 在main函数中添加发送逻辑
   setInterval(() => sendData(createNewMessageData(), '新消息数据'), 20000);
   ```

6. **编写单元测试**（可选）  
   创建`test-new-protocol.js`进行独立验证。

### PlatformCmd协议实现细节

PlatformCmd协议用于发送平台控制命令，如火炮发射、无人机航线规划等。

**消息结构**：
```javascript
{
  commandID: 时间戳,           // 命令ID
  platformName: "artillery1",  // 平台名称
  platformType: "Artillery",   // 平台类型  
  command: 10,                 // Arty_Fire (火炮发射)
  fireParam: {
    weaponName: "用户输入的武器名称",
    targetName: "用户输入的目标名称", 
    quantity: 1                // 发射次数
  }
}
```

**数据包格式**：
```
[包头] [协议ID] [包类型] [数据长度] [Protobuf数据]
 0xAA   0x01     0x2A     4字节LE    变长
 0x55
```

- **包类型**: 0x2A (PackType_PlatformCmd)
- **协议ID**: 0x01
- **组播地址**: 239.255.43.21:10086

**支持的PlatformCommand枚举值**：
- `Arty_Load = 9` - 火炮装填
- `Arty_Fire = 10` - 火炮发射

**实现文件**：
- `src/protobuf/PlatformCmd.proto` - 协议定义
- `src/main/services/protobuf-parser.service.ts` - 解析逻辑
- `src/main/services/multicast-sender.service.ts` - 发送服务
- `src/testScipt/test-platform-cmd.js` - 测试脚本

### PlatformStatus协议实现细节

PlatformStatus协议用于上报平台状态信息，包括平台基础信息、设备信息、运动参数等。

**支持的数据结构**：
- **平台基础信息 (PlatformBase)**: 名称、类型、阵营、编队、位置信息
- **设备信息**: 推进器、通信设备、传感器、武器、跟踪目标
- **运动参数 (PartParam)**: 转动模式、转动范围限制、当前姿态角度

**数据包格式**：
```
[包头] [协议ID] [包类型] [数据长度] [Protobuf数据]
 0xAA   0x01     0x29     4字节LE    变长
 0x55
```

- **包类型**: 0x29 (PackType_PlatformStatus)
- **协议ID**: 0x01
- **组播地址**: 239.255.43.21:10086

**实现文件**：
- `src/protobuf/PlatformStatus.proto` - 协议定义
- `src/main/services/protobuf-parser.service.ts` - 解析逻辑
- `src/testScipt/test-platform-status.js` - 测试脚本

### Uav_Set_Speed命令实现细节

根据protobuf定义中新增的`Uav_Set_Speed`命令，在命令控制测试页面添加了无人机速度设置功能。

**Protobuf定义**：
```protobuf
enum PlatformCommand {
  // ... 其他命令
  Uav_Set_Speed = 9; // 设定无人机速度
}

message SetSpeedparam {
  optional int32 speed = 1;
}

message PlatformCmd {
  // ... 其他字段
  optional SetSpeedparam setSpeedParam = 8; // 速度设定参数
}
```

**前端界面**：
- 在"导航控制"区域新增"设置速度"按钮
- 对话框包含平台名称（只读）和目标速度（1-100 m/s）输入
- 输入范围限制在1-100 m/s，支持步进调节

**数据结构**：
```typescript
const setSpeedForm = reactive({
  speed: 10  // 默认速度 10 m/s
});

const commandData = {
  commandID: Date.now(),
  platformName: String(selectedPlatform.value),
  command: 9, // Uav_Set_Speed
  setSpeedParam: {
    speed: Number(setSpeedForm.speed)
  }
};
```

**后端支持**：
- 在`PlatformCmdData`接口中新增`setSpeedParam`字段
- 在`multicast-sender.service.ts`中添加对`SetSpeedparam`消息类型的查找和创建逻辑
- 支持容错处理，如果类型未找到会记录警告

**实现文件**：
- `src/protobuf/PlatformCmd.proto` - 命令枚举和参数结构定义
- `src/main/services/multicast-sender.service.ts` - 发送服务中添加速度设置参数处理
- `src/renderer/views/pages/CommandTestPage.vue` - 前端界面实现
- `docs/SPEED_SETTING_FEATURE.md` - 功能详细文档

**Section sources**
- [src/protobuf/PublicStruct.proto](file://src/protobuf/PublicStruct.proto#L0-L57)
- [src/main/services/protobuf-parser.service.ts](file://src/main/services/protobuf-parser.service.ts#L0-L458)
- [src/protobuf/PlatformCmd.proto](file://src/protobuf/PlatformCmd.proto#L0-L39) - *最近提交中新增*
- [src/protobuf/PlatformStatus.proto](file://src/protobuf/PlatformStatus.proto#L0-L103) - *最近提交中新增*
- [src/main/services/multicast-sender.service.ts](file://src/main/services/multicast-sender.service.ts#L0-L1065)
- [src/protobuf/UaviationSimulationStruct.proto](file://src/protobuf/UaviationSimulationStruct.proto#L0-L211)
- [docs/SPEED_SETTING_FEATURE.md](file://docs/SPEED_SETTING_FEATURE.md#L0-L140)

## 数据库迁移脚本标准流程

项目使用SQLite3数据库，通过迁移脚本管理模式变更。

### 迁移脚本结构

每个迁移脚本位于`src/main/database/migrations/`目录，命名格式为`001-initial-schema.js`。

```javascript
// src/main/database/migrations/001-initial-schema.js
import type { Database } from 'sqlite3';

export const up = (db: Database) => {
  db.exec(`
    CREATE TABLE IF NOT EXISTS users (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL CHECK(length(name) > 2),
      email TEXT UNIQUE NOT NULL,
      age INTEGER,
      company_id INTEGER,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
    );
    
    CREATE TABLE IF NOT EXISTS companies (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      type TEXT,
      capacity INTEGER,
      owner TEXT,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
    );
  `);
};

export const down = (db: Database) => {
  db.exec(`
    DROP TABLE IF EXISTS users;
    DROP TABLE IF EXISTS companies;
  `);
};
```

### 标准流程

1. **创建新迁移脚本**  
   ```bash
   # 手动创建，确保序号递增
   touch src/main/database/migrations/003-add-new-table.js
   ```

2. **编写`up`和`down`函数**  
   - `up`: 应用变更（创建表、添加列等）
   - `down`: 撤销变更（删除表、删除列等）

3. **在`db.service.ts`中注册迁移**  
   ```typescript
   // src/main/database/db.service.ts
   export class DBService {
     private migrations = [
       require('./migrations/001-initial-schema'),
       require('./migrations/002-update-table-users'),
       require('./migrations/003-add-new-table'), // 新增
     ];
   }
   ```

4. **运行迁移**  
   在`main.ts`中，`dbService.applyMigrations()`会在应用启动时自动执行。

5. **添加种子数据**（可选）  
   在`src/main/database/seeds/`中创建种子脚本，用于初始化测试数据。

**Section sources**
- [src/main/database/migrations/001-initial-schema.js](file://src/main/database/migrations/001-initial-schema.js)
- [src/main/database/migrations/002-update-table-users.js](file://src/main/database/migrations/002-update-table-users.js)
- [src/main/database/seeds/001-sample-data.js](file://src/main/database/seeds/001-sample-data.js)
- [src/main/database/db.service.ts](file://src/main/database/db.service.ts)

## 代码风格与提交规范

### 代码风格

- **语言**: TypeScript
- **格式化**: 使用Prettier，配置见`.prettierrc`
- **命名**:
  - 变量和函数：`camelCase`
  - 类和接口：`PascalCase`
  - 常量：`UPPER_CASE`
- **注释**: 关键逻辑必须添加JSDoc注释

### 提交信息格式

采用[Conventional Commits](https://www.conventionalcommits.org/)规范：

```
<type>(<scope>): <subject>
<BLANK LINE>
<body>
<BLANK LINE>
<footer>
```

**类型（type）**:
- `feat`: 新功能
- `fix`: 修复bug
- `docs`: 文档更新
- `style`: 代码格式调整
- `refactor`: 代码重构
- `test`: 测试相关
- `chore`: 构建或辅助工具变动

**示例**:
```
feat(multicast): add support for new protocol type 0x30

- Add NewProtocol.proto definition
- Implement parseNewMessage in protobuf-parser.service
- Update test-protobuf-multicast.js to send test data

Closes #123
```

### Pull Request审查要求

1. **功能完整性**: PR必须完整实现一个功能或修复一个bug
2. **代码质量**: 无明显性能问题，遵循代码风格
3. **测试覆盖**: 新功能必须包含相应的测试
4. **文档更新**: API变更需同步更新文档
5. **审查流程**: 至少一名核心成员批准后方可合并

**Section sources**
- [package.json](file://package.json)
- [.prettierrc](file://.prettierrc)