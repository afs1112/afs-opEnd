# é¡¹ç›®æ¦‚è¿°

<cite>
**æœ¬æ–‡æ¡£å¼•ç”¨çš„æ–‡ä»¶**  
- [README.md](file://README.md)
- [MULTICAST_README.md](file://MULTICAST_README.md)
- [PLATFORM_CMD_README.md](file://PLATFORM_CMD_README.md)
- [PLATFORM_STATUS_README.md](file://PLATFORM_STATUS_README.md)
- [src/main/main.ts](file://src/main/main.ts)
- [src/main/services/multicast.service.ts](file://src/main/services/multicast.service.ts)
- [src/main/services/protobuf-parser.service.ts](file://src/main/services/protobuf-parser.service.ts)
- [src/main/database/db.service.ts](file://src/main/database/db.service.ts)
- [src/main/services/multicast-sender.service.ts](file://src/main/services/multicast-sender.service.ts)
- [src/renderer/main.ts](file://src/renderer/main.ts)
- [src/renderer/views/pages/MulticastPage.vue](file://src/renderer/views/pages/MulticastPage.vue)
- [src/renderer/views/pages/ArtilleryOperationPage.vue](file://src/renderer/views/pages/ArtilleryOperationPage.vue)
- [src/protobuf/PlatformStatus.proto](file://src/protobuf/PlatformStatus.proto)
- [src/protobuf/PlatformCmd.proto](file://src/protobuf/PlatformCmd.proto)
- [src/protobuf/UavFlyStatusStruct.proto](file://src/protobuf/UavFlyStatusStruct.proto)
- [src/protobuf/UavNavMonitorStruct.proto](file://src/protobuf/UavNavMonitorStruct.proto)
- [src/protobuf/PublicStruct.proto](file://src/protobuf/PublicStruct.proto)
- [src/main/preload.ts](file://src/main/preload.ts)
</cite>

## æ›´æ–°æ‘˜è¦
**å˜æ›´å†…å®¹**  
- æ›´æ–°äº†ç®€ä»‹éƒ¨åˆ†ï¼Œå¢åŠ äº†å¹³å°çŠ¶æ€ç›‘æ§å’Œç«ç‚®æ§åˆ¶å‘½ä»¤çš„æ–°åŠŸèƒ½
- æ‰©å±•äº†æ ¸å¿ƒç»„ä»¶åˆ†æï¼Œæ–°å¢äº†ç»„æ’­å‘é€æœåŠ¡å’Œç«ç‚®æ“ä½œé¡µé¢
- æ›´æ–°äº†æ¶æ„æ¦‚è§ˆï¼Œå¢åŠ äº†åŒå‘é€šä¿¡æœºåˆ¶
- æ–°å¢äº†å¹³å°çŠ¶æ€åè®®å’Œç«ç‚®æ§åˆ¶å‘½ä»¤çš„è¯¦ç»†åˆ†æ
- æ›´æ–°äº†ä¾èµ–åˆ†æï¼Œå¢åŠ äº†æ–°åŠŸèƒ½çš„ä¾èµ–å…³ç³»
- æ›´æ–°äº†æ•…éšœæ’é™¤æŒ‡å—ï¼Œå¢åŠ äº†æ–°åŠŸèƒ½çš„å¸¸è§é—®é¢˜

## ç›®å½•
1. [ç®€ä»‹](#ç®€ä»‹)
2. [é¡¹ç›®ç»“æ„](#é¡¹ç›®ç»“æ„)
3. [æ ¸å¿ƒç»„ä»¶](#æ ¸å¿ƒç»„ä»¶)
4. [æ¶æ„æ¦‚è§ˆ](#æ¶æ„æ¦‚è§ˆ)
5. [è¯¦ç»†ç»„ä»¶åˆ†æ](#è¯¦ç»†ç»„ä»¶åˆ†æ)
6. [ä¾èµ–åˆ†æ](#ä¾èµ–åˆ†æ)
7. [æ€§èƒ½è€ƒé‡](#æ€§èƒ½è€ƒé‡)
8. [æ•…éšœæ’é™¤æŒ‡å—](#æ•…éšœæ’é™¤æŒ‡å—)
9. [ç»“è®º](#ç»“è®º)

## ç®€ä»‹
afs-opEnd æ˜¯ä¸€ä¸ªåŸºäº Electron æ¡†æ¶çš„æ— äººæœºé€šä¿¡æ¨¡æ‹Ÿä¸ç›‘æ§æ¡Œé¢åº”ç”¨ï¼Œæ—¨åœ¨ä¸ºå¼€å‘äººå‘˜å’Œæµ‹è¯•äººå‘˜æä¾›ä¸€ä¸ªå¼ºå¤§çš„å·¥å…·ï¼Œç”¨äºç›‘å¬ã€è§£æå’Œå¯è§†åŒ–æ— äººæœºé€šä¿¡æ•°æ®ã€‚è¯¥åº”ç”¨æ”¯æŒ UDP ç»„æ’­ç›‘å¬å’Œ Protobuf åè®®è§£æï¼Œèƒ½å¤Ÿå®æ—¶æ˜¾ç¤ºæ¥æ”¶åˆ°çš„æ•°æ®åŒ…ä¿¡æ¯ï¼Œå¹¶æ”¯æŒæ•°æ®å¯¼å‡ºå’Œæ¸…ç©ºåŠŸèƒ½ã€‚é€šè¿‡é›†æˆ better-sqlite3 å’Œ protobufjs ç­‰å…³é”®æŠ€æœ¯æ ˆï¼Œafs-opEnd å®ç°äº†é«˜æ•ˆçš„æ•°æ®æŒä¹…åŒ–å’Œåè®®è§£æèƒ½åŠ›ã€‚

æœ€æ–°ç‰ˆæœ¬å¢åŠ äº†å¯¹å¹³å°çŠ¶æ€ç›‘æ§å’Œç«ç‚®æ§åˆ¶å‘½ä»¤çš„æ”¯æŒã€‚å¹³å°çŠ¶æ€åŠŸèƒ½å…è®¸ç³»ç»Ÿæ¥æ”¶å’Œè§£æè¯¦ç»†çš„å¹³å°ä¿¡æ¯ï¼ŒåŒ…æ‹¬ä½ç½®ã€çŠ¶æ€ã€è®¾å¤‡é…ç½®ç­‰ï¼Œä¸ºæ— äººæœºå­¦ä¹ åœºæ™¯æä¾›äº†æ›´å…¨é¢çš„æ€åŠ¿æ„ŸçŸ¥èƒ½åŠ›ã€‚ç«ç‚®æ§åˆ¶å‘½ä»¤åŠŸèƒ½åˆ™å®ç°äº†ä»ç«ç‚®æ“ä½œé¡µé¢å‘é€æ§åˆ¶æŒ‡ä»¤çš„èƒ½åŠ›ï¼Œæ”¯æŒç”¨æˆ·è¾“å…¥æ­¦å™¨åç§°å’Œç›®æ ‡åç§°ï¼Œå¢å¼ºäº†ç³»ç»Ÿçš„äº¤äº’æ€§å’Œå®ç”¨æ€§ã€‚

**Section sources**
- [README.md](file://README.md)
- [MULTICAST_README.md](file://MULTICAST_README.md)
- [PLATFORM_CMD_README.md](file://PLATFORM_CMD_README.md)
- [PLATFORM_STATUS_README.md](file://PLATFORM_STATUS_README.md)

## é¡¹ç›®ç»“æ„
afs-opEnd é¡¹ç›®é‡‡ç”¨åˆ†å±‚æ¶æ„è®¾è®¡ï¼Œä¸»è¦åˆ†ä¸ºä¸‰ä¸ªéƒ¨åˆ†ï¼šä¸»è¿›ç¨‹ï¼ˆmainï¼‰ã€æ¸²æŸ“è¿›ç¨‹ï¼ˆrendererï¼‰å’Œåè®®å®šä¹‰ï¼ˆprotobufï¼‰ã€‚ä¸»è¿›ç¨‹è´Ÿè´£å¤„ç†ç³»ç»Ÿçº§æ“ä½œï¼Œå¦‚æ•°æ®åº“ç®¡ç†å’Œç»„æ’­ç›‘å¬ï¼›æ¸²æŸ“è¿›ç¨‹åˆ™è´Ÿè´£ç”¨æˆ·ç•Œé¢çš„å±•ç¤ºå’Œäº¤äº’ï¼›åè®®å®šä¹‰éƒ¨åˆ†åŒ…å«äº†æ‰€æœ‰é€šä¿¡åè®®çš„ Protobuf å®šä¹‰æ–‡ä»¶ã€‚

```mermaid
graph TB
subgraph "ä¸»è¿›ç¨‹"
main["src/main"]
database["database"]
services["services"]
main_ts["main.ts"]
preload_ts["preload.ts"]
end
subgraph "æ¸²æŸ“è¿›ç¨‹"
renderer["src/renderer"]
assets["assets"]
services_r["services"]
typings["typings"]
views["views"]
main_r_ts["main.ts"]
App_vue["App.vue"]
end
subgraph "åè®®å®šä¹‰"
protobuf["src/protobuf"]
PlatformCmd_proto["PlatformCmd.proto"]
PlatformStatus_proto["PlatformStatus.proto"]
PublicStruct_proto["PublicStruct.proto"]
UavFlyMonitorStruct_proto["UavFlyMonitorStruct.proto"]
UavFlyStatusStruct_proto["UavFlyStatusStruct.proto"]
UavNavMonitorStruct_proto["UavNavMonitorStruct.proto"]
UaviationSimulationStruct_proto["UaviationSimulationStruct.proto"]
end
main --> database
main --> services
main --> main_ts
main --> preload_ts
renderer --> assets
renderer --> services_r
renderer --> typings
renderer --> views
renderer --> main_r_ts
renderer --> App_vue
protobuf --> PlatformCmd_proto
protobuf --> PlatformStatus_proto
protobuf --> PublicStruct_proto
protobuf --> UavFlyMonitorStruct_proto
protobuf --> UavFlyStatusStruct_proto
protobuf --> UavNavMonitorStruct_proto
protobuf --> UaviationSimulationStruct_proto
```

**Diagram sources**
- [src/main/main.ts](file://src/main/main.ts)
- [src/renderer/main.ts](file://src/renderer/main.ts)
- [src/protobuf/PlatformStatus.proto](file://src/protobuf/PlatformStatus.proto)

**Section sources**
- [src/main/main.ts](file://src/main/main.ts)
- [src/renderer/main.ts](file://src/renderer/main.ts)
- [src/protobuf/PlatformStatus.proto](file://src/protobuf/PlatformStatus.proto)

## æ ¸å¿ƒç»„ä»¶
afs-opEnd çš„æ ¸å¿ƒç»„ä»¶åŒ…æ‹¬ä¸»è¿›ç¨‹ã€æ¸²æŸ“è¿›ç¨‹ã€ç»„æ’­æœåŠ¡ã€Protobuf è§£ææœåŠ¡ã€æ•°æ®åº“æœåŠ¡ã€ç»„æ’­å‘é€æœåŠ¡å’Œç«ç‚®æ“ä½œé¡µé¢ã€‚ä¸»è¿›ç¨‹è´Ÿè´£å¯åŠ¨åº”ç”¨ã€ç®¡ç†æ•°æ®åº“å’Œç›‘å¬ç»„æ’­æ•°æ®åŒ…ï¼›æ¸²æŸ“è¿›ç¨‹è´Ÿè´£å±•ç¤ºç”¨æˆ·ç•Œé¢å’Œå¤„ç†ç”¨æˆ·äº¤äº’ï¼›ç»„æ’­æœåŠ¡è´Ÿè´£æ¥æ”¶å’Œè§£æç»„æ’­æ•°æ®åŒ…ï¼›Protobuf è§£ææœåŠ¡è´Ÿè´£è§£æ Protobuf æ ¼å¼çš„æ•°æ®ï¼›æ•°æ®åº“æœåŠ¡è´Ÿè´£æ•°æ®çš„æŒä¹…åŒ–å­˜å‚¨ï¼›ç»„æ’­å‘é€æœåŠ¡è´Ÿè´£å‘é€æ§åˆ¶å‘½ä»¤ï¼›ç«ç‚®æ“ä½œé¡µé¢æä¾›ç”¨æˆ·å‹å¥½çš„ç«ç‚®æ§åˆ¶ç•Œé¢ã€‚

**Section sources**
- [src/main/main.ts](file://src/main/main.ts)
- [src/main/services/multicast.service.ts](file://src/main/services/multicast.service.ts)
- [src/main/services/protobuf-parser.service.ts](file://src/main/services/protobuf-parser.service.ts)
- [src/main/database/db.service.ts](file://src/main/database/db.service.ts)
- [src/main/services/multicast-sender.service.ts](file://src/main/services/multicast-sender.service.ts)
- [src/renderer/main.ts](file://src/renderer/main.ts)
- [src/renderer/views/pages/MulticastPage.vue](file://src/renderer/views/pages/MulticastPage.vue)
- [src/renderer/views/pages/ArtilleryOperationPage.vue](file://src/renderer/views/pages/ArtilleryOperationPage.vue)

## æ¶æ„æ¦‚è§ˆ
afs-opEnd é‡‡ç”¨ä¸»è¿›ç¨‹ä¸æ¸²æŸ“è¿›ç¨‹åˆ†ç¦»çš„è®¾è®¡ï¼Œä¸»è¿›ç¨‹è´Ÿè´£ç³»ç»Ÿçº§æ“ä½œï¼Œå¦‚æ•°æ®åº“ç®¡ç†å’Œç»„æ’­ç›‘å¬ï¼Œè€Œæ¸²æŸ“è¿›ç¨‹è´Ÿè´£ç”¨æˆ·ç•Œé¢çš„å±•ç¤ºå’Œäº¤äº’ã€‚ä¸»è¿›ç¨‹é€šè¿‡ IPC æœºåˆ¶ä¸æ¸²æŸ“è¿›ç¨‹é€šä¿¡ï¼Œä¼ é€’æ•°æ®å’ŒçŠ¶æ€ä¿¡æ¯ã€‚ç»„æ’­æœåŠ¡ä½¿ç”¨ Node.js çš„ dgram æ¨¡å—åˆ›å»º UDP socket ç›‘å¬ç»„æ’­æ•°æ®åŒ…ï¼Œå¹¶é€šè¿‡ IPC æœºåˆ¶å°†æ¥æ”¶åˆ°çš„æ•°æ®åŒ…ä¼ é€’ç»™æ¸²æŸ“è¿›ç¨‹ã€‚Protobuf è§£ææœåŠ¡è´Ÿè´£è§£æ Protobuf æ ¼å¼çš„æ•°æ®ï¼Œå¹¶å°†è§£æç»“æœä¼ é€’ç»™æ¸²æŸ“è¿›ç¨‹ã€‚æ•°æ®åº“æœåŠ¡ä½¿ç”¨ better-sqlite3 å®ç°æ•°æ®çš„æŒä¹…åŒ–å­˜å‚¨ã€‚

æ–°å¢çš„ç»„æ’­å‘é€æœåŠ¡å…è®¸æ¸²æŸ“è¿›ç¨‹é€šè¿‡ IPC æœºåˆ¶å‘ä¸»è¿›ç¨‹å‘é€æ§åˆ¶å‘½ä»¤ï¼Œä¸»è¿›ç¨‹å°†è¿™äº›å‘½ä»¤ç¼–ç ä¸º Protobuf æ ¼å¼å¹¶é€šè¿‡ UDP ç»„æ’­å‘é€å‡ºå»ã€‚è¿™ç§åŒå‘é€šä¿¡æœºåˆ¶ä½¿å¾—ç³»ç»Ÿæ—¢èƒ½æ¥æ”¶å’Œç›‘æ§æ•°æ®ï¼Œåˆèƒ½ä¸»åŠ¨å‘é€æ§åˆ¶æŒ‡ä»¤ï¼Œå½¢æˆäº†å®Œæ•´çš„é€šä¿¡é—­ç¯ã€‚

```mermaid
graph TB
subgraph "ä¸»è¿›ç¨‹"
main["src/main"]
database["database"]
services["services"]
main_ts["main.ts"]
preload_ts["preload.ts"]
end
subgraph "æ¸²æŸ“è¿›ç¨‹"
renderer["src/renderer"]
assets["assets"]
services_r["services"]
typings["typings"]
views["views"]
main_r_ts["main.ts"]
App_vue["App.vue"]
end
subgraph "åè®®å®šä¹‰"
protobuf["src/protobuf"]
PlatformCmd_proto["PlatformCmd.proto"]
PlatformStatus_proto["PlatformStatus.proto"]
PublicStruct_proto["PublicStruct.proto"]
UavFlyMonitorStruct_proto["UavFlyMonitorStruct.proto"]
UavFlyStatusStruct_proto["UavFlyStatusStruct.proto"]
UavNavMonitorStruct_proto["UavNavMonitorStruct.proto"]
UaviationSimulationStruct_proto["UaviationSimulationStruct.proto"]
end
main_ts --> |IPC| renderer
services --> |IPC| renderer
database --> |IPC| renderer
renderer --> |IPC| main_ts
```

**Diagram sources**
- [src/main/main.ts](file://src/main/main.ts)
- [src/main/services/multicast.service.ts](file://src/main/services/multicast.service.ts)
- [src/main/services/protobuf-parser.service.ts](file://src/main/services/protobuf-parser.service.ts)
- [src/main/database/db.service.ts](file://src/main/database/db.service.ts)
- [src/main/services/multicast-sender.service.ts](file://src/main/services/multicast-sender.service.ts)
- [src/renderer/main.ts](file://src/renderer/main.ts)
- [src/renderer/views/pages/MulticastPage.vue](file://src/renderer/views/pages/MulticastPage.vue)
- [src/renderer/views/pages/ArtilleryOperationPage.vue](file://src/renderer/views/pages/ArtilleryOperationPage.vue)

## è¯¦ç»†ç»„ä»¶åˆ†æ
### ä¸»è¿›ç¨‹åˆ†æ
ä¸»è¿›ç¨‹æ˜¯ afs-opEnd çš„æ ¸å¿ƒï¼Œè´Ÿè´£å¯åŠ¨åº”ç”¨ã€ç®¡ç†æ•°æ®åº“å’Œç›‘å¬ç»„æ’­æ•°æ®åŒ…ã€‚ä¸»è¿›ç¨‹é€šè¿‡ `main.ts` æ–‡ä»¶ä¸­çš„ `createWindow` å‡½æ•°åˆ›å»ºä¸»çª—å£ï¼Œå¹¶é€šè¿‡ `preload.ts` æ–‡ä»¶ä¸­çš„ `contextBridge` æš´éœ² IPC æ¥å£ç»™æ¸²æŸ“è¿›ç¨‹ã€‚ä¸»è¿›ç¨‹è¿˜é€šè¿‡ `db.service.ts` æ–‡ä»¶ä¸­çš„ `DBService` ç±»ç®¡ç†æ•°æ®åº“ï¼Œé€šè¿‡ `multicast.service.ts` æ–‡ä»¶ä¸­çš„ `MulticastService` ç±»ç›‘å¬ç»„æ’­æ•°æ®åŒ…ã€‚

#### ä¸»è¿›ç¨‹å…¥å£æ–‡ä»¶
```typescript
import { app, BrowserWindow, dialog, ipcMain, session, Menu } from "electron";
import { join } from "path";
import fs from "fs";
import * as dotenv from 'dotenv';
import { dbService } from "./database/db.service";
import { multicastService, MulticastPacket } from "./services/multicast.service";
import { multicastSenderService, PlatformCmdData } from "./services/multicast-sender.service";

// åŠ è½½ç¯å¢ƒé…ç½®
const envPath = join(app.getAppPath(), 'config.env');
dotenv.config({ path: envPath });

app.whenReady().then(async () => {
  try {
    await dbService.applyMigrations();
    await dbService.runSeeds();

    createWindow();

    // å¯åŠ¨ç»„æ’­ç›‘å¬æœåŠ¡
    try {
      await multicastService.start();
    } catch (error) {
      console.error("ç»„æ’­æœåŠ¡å¯åŠ¨å¤±è´¥:", error);
    }

    // åˆå§‹åŒ–ç»„æ’­å‘é€æœåŠ¡
    try {
      await multicastSenderService.initialize();
      console.log('âœ… ç»„æ’­å‘é€æœåŠ¡åˆå§‹åŒ–æˆåŠŸ');
    } catch (error) {
      console.error("âŒ ç»„æ’­å‘é€æœåŠ¡åˆå§‹åŒ–å¤±è´¥:", error);
    }

    session.defaultSession.webRequest.onHeadersReceived((details, callback) => {
      callback({
        responseHeaders: {
          ...details.responseHeaders,
          "Content-Security-Policy": ["script-src 'self'"],
        },
      });
    });

    app.on("activate", () => {
      if (BrowserWindow.getAllWindows().length === 0) {
        createWindow();
      }
    });
  } catch (error) {
    console.error("Initialization failed:", error);
    app.quit();
  }
});

// ç»„æ’­æœåŠ¡IPCå¤„ç†
ipcMain.handle("multicast:start", async () => {
  try {
    await multicastService.start();
    return { success: true };
  } catch (error: any) {
    return { success: false, error: error.message };
  }
});

ipcMain.handle("multicast:stop", async () => {
  try {
    await multicastService.stop();
    return { success: true };
  } catch (error: any) {
    return { success: false, error: error.message };
  }
});

ipcMain.handle("multicast:getStatus", () => {
  return multicastService.getStatus();
});

ipcMain.handle("multicast:getConfig", () => {
  return {
    address: process.env.MULTICAST_ADDRESS || '239.255.43.21',
    port: parseInt(process.env.MULTICAST_PORT || '10086'),
    interfaceAddress: process.env.INTERFACE_ADDRESS || '0.0.0.0'
  };
});

ipcMain.handle("multicast:updateConfig", (_, address: string, port: number, interfaceAddr: string) => {
  try {
    multicastService.updateConfig(address, port, interfaceAddr);
    return { success: true };
  } catch (error: any) {
    return { success: false, error: error.message };
  }
});

// ç»„æ’­å‘é€æœåŠ¡IPCå¤„ç†
ipcMain.handle("multicast:sendPlatformCmd", async (_, data: PlatformCmdData) => {
  try {
    // æ£€æŸ¥æœåŠ¡æ˜¯å¦å·²åˆå§‹åŒ–ï¼Œå¦‚æœæ²¡æœ‰åˆ™å°è¯•é‡æ–°åˆå§‹åŒ–
    if (!multicastSenderService.isInitialized()) {
      console.log('[Main] MulticastSenderæœªåˆå§‹åŒ–ï¼Œå°è¯•é‡æ–°åˆå§‹åŒ–...');
      try {
        await multicastSenderService.initialize();
        console.log('[Main] âœ… MulticastSenderé‡æ–°åˆå§‹åŒ–æˆåŠŸ');
      } catch (initError) {
        console.error('[Main] âŒ MulticastSenderé‡æ–°åˆå§‹åŒ–å¤±è´¥:', initError);
        return { success: false, error: `åˆå§‹åŒ–å¤±è´¥: ${initError instanceof Error ? initError.message : String(initError)}` };
      }
    }
    
    await multicastSenderService.sendPlatformCmd(data);
    return { success: true };
  } catch (error: any) {
    console.error('å‘é€PlatformCmdå¤±è´¥:', error);
    return { success: false, error: error.message };
  }
});

// ç›‘å¬ç»„æ’­æ•°æ®åŒ…å¹¶è½¬å‘ç»™æ¸²æŸ“è¿›ç¨‹
multicastService.on('packet', (packet: MulticastPacket) => {
  const windows = BrowserWindow.getAllWindows();
  windows.forEach(window => {
    window.webContents.send('multicast:packet', packet);
  });
});

multicastService.on('error', (error) => {
  const windows = BrowserWindow.getAllWindows();
  windows.forEach(window => {
    window.webContents.send('multicast:error', error.message);
  });
});

ipcMain.handle("database:query", (_, sql, params) => {
  const stmt = dbService.db.prepare(sql);
  return params ? stmt.all(params) : stmt.all();
});

ipcMain.handle("database:execute", (_, sql, params) => {
  try {
    const stmt = dbService.db.prepare(sql);
    const result = params ? stmt.run(params) : stmt.run();

    return {
      success: true,
      lastId: result.lastInsertRowid,
      changes: result.changes,
    };
  } catch (error: any) {
    return {
      success: false,
      error: error.message,
    };
  }
});

ipcMain.handle("database:reset", async () => {
  const dbFile = join(app.getPath("userData"), "app-database.sqlite");

  try {
    if (dbService.db) {
      dbService.db.close();
      await new Promise(resolve => setTimeout(resolve, 500));
    }

    let retries = 5;
    while (retries-- > 0) {
      try {
        if (fs.existsSync(dbFile)) {
          fs.unlinkSync(dbFile);
        }
        break;
      } catch (err: any) {
        if (err.code === 'EBUSY' && retries > 0) {
          await new Promise(resolve => setTimeout(resolve, 200));
          continue;
        }
        throw err;
      }
    }

    dbService.initializeDatabase();
    await dbService.applyMigrations();
    await dbService.runSeeds();
    
    return { success: true };
  } catch (error: any) {
    console.error("Reset database failed:", error);
    return { 
      success: false,
      error: error.message,
      code: error.code
    };
  }
});

function createWindow() {
  const mainWindow = new BrowserWindow({
    width: 1400,
    height: 1000,
    webPreferences: {
      devTools: true,
      preload: join(__dirname, "preload.js"),
      nodeIntegration: false,
      contextIsolation: true,
    },
  });

  // åˆ›å»ºèœå•
  const template = [
    {
      label: 'å¼€å‘',
      submenu: [
        {
          label: 'æ‰“å¼€å¼€å‘è€…å·¥å…·',
          accelerator: 'CmdOrCtrl+Shift+I',
          click: () => {
            mainWindow.webContents.openDevTools();
          }
        },
        {
          label: 'é‡æ–°åŠ è½½',
          accelerator: 'CmdOrCtrl+R',
          click: () => {
            mainWindow.reload();
          }
        },
        {
          label: 'å¼ºåˆ¶é‡æ–°åŠ è½½',
          accelerator: 'CmdOrCtrl+Shift+R',
          click: () => {
            mainWindow.webContents.reloadIgnoringCache();
          }
        }
      ]
    }
  ];

  const menu = Menu.buildFromTemplate(template);
  Menu.setApplicationMenu(menu);

  if (process.env.NODE_ENV === "development") {
    const rendererPort = process.argv[2];
    mainWindow.loadURL(`http://localhost:${rendererPort}`);
    
    // åœ¨å¼€å‘æ¨¡å¼ä¸‹è‡ªåŠ¨æ‰“å¼€å¼€å‘è€…å·¥å…·
    mainWindow.webContents.once('dom-ready', () => {
      mainWindow.webContents.openDevTools();
    });
  } else {
    mainWindow.loadFile(join(app.getAppPath(), "renderer", "index.html"));
  }
}

app.on("window-all-closed", function () {
  if (process.platform !== "darwin") app.quit();
});

ipcMain.handle("show-save-dialog", async (event, options) => {
  const { filePath } = await dialog.showSaveDialog({
    title: options.title || "Save File",
    defaultPath:
      options.defaultPath ||
      join(app.getPath("downloads"), options.defaultFileName || "export.json"),
    filters: options.filters || [
      { name: "JSON Files", extensions: ["json"] },
      { name: "All Files", extensions: ["*"] },
    ],
    properties: ["createDirectory"],
  });
  return filePath;
});

ipcMain.handle("export-file", async (event, { filePath, data }) => {
  try {
    const serializableData = JSON.parse(JSON.stringify(data));
    await fs.promises.writeFile(
      filePath,
      JSON.stringify(serializableData, null, 2),
      "utf8"
    );
    return { success: true, path: filePath };
  } catch (err: any) {
    console.error("Error writing file", err);
    return { success: false, error: err.message };
  }
});

ipcMain.handle("export-database", async () => {
  try {
    const srcDb = join(app.getPath("userData"), "app-database.sqlite");

    const { canceled, filePath } = await dialog.showSaveDialog({
      title: "Export Database",
      buttonLabel: "Export",
      defaultPath: join(app.getPath("documents"), "database_backup.sqlite"),
      filters: [
        { name: "SQLite Database", extensions: ["sqlite", "db"] },
        { name: "All Files", extensions: ["*"] },
      ],
      properties: [
        "createDirectory",
        "showOverwriteConfirmation",
        "dontAddToRecent",
      ],
    });

    if (canceled || !filePath) {
      return { success: false, error: "Export cancelled" };
    }

    if (dbService.db.open) {
      dbService.db.close();
    }

    await fs.promises.copyFile(srcDb, filePath);

    await dbService.initializeDatabase();

    const { size } = await fs.promises.stat(filePath);

    return { success: true, path: filePath, size };
  } catch (err: any) {
    console.error("Export DB failed:", err);
    return { success: false, error: err.message, code: err.code };
  }
});

ipcMain.handle("export-sql-query", async () => {
  try {
    const tables = ["companies", "users"];
    let sqlContent = "BEGIN TRANSACTION;\n\n";

    for (const table of tables) {
      const data = dbService.db.prepare(`SELECT * FROM ${table}`).all();
      if (data.length === 0) continue;

      const schema = dbService.db.prepare(`PRAGMA table_info(${table})`).all();
      const primaryKey = schema.find((col) => col.pk === 1)?.name || "id";
      const columns = Object.keys(data[0]);

      // Táº¡o máº£ng giÃ¡ trá»‹ cho multi-row insert
      const valuesBatch = data.map((row) =>
        columns.map((col) => {
          const value = row[col];
          if (value === null) return "NULL";
          if (typeof value === "string")
            return `'${value.replace(/'/g, "''")}'`;
          if (value instanceof Date) return `'${value.toISOString()}'`;
          return value;
        })
      );

      // Táº¡o má»‡nh Ä‘á» UPDATE tá»« schema
      const updateSet = columns
        .filter((col) => col !== primaryKey)
        .map((col) => `${col} = excluded.${col}`)
        .join(",\n    ");

      sqlContent += `-- UPSERT for ${table}
INSERT INTO ${table} (${columns.join(", ")})
VALUES\n  `;

      // ThÃªm cÃ¡c giÃ¡ trá»‹ theo batch
      sqlContent += valuesBatch
        .map((values) => `(${values.join(", ")})`)
        .join(",\n  ");

      sqlContent += `\nON CONFLICT(${primaryKey}) DO UPDATE SET
    ${updateSet};\n\n`;
    }

    sqlContent += "COMMIT;";

    // Pháº§n dialog vÃ  write file giá»¯ nguyÃªn
    const { filePath } = await dialog.showSaveDialog({
      title: "Export SQL Query",
      filters: [{ name: "SQL Files", extensions: ["sql"] }],
      defaultPath: `database_upsert_${new Date()
        .toISOString()
        .slice(0, 10)}.sql`,
    });

    if (!filePath) return { success: false, error: "Export cancelled" };

    await fs.promises.writeFile(filePath, sqlContent);
    return { success: true, path: filePath };
  } catch (error: any) {
    return {
      success: false,
      error: error.message,
      code: error.code,
    };
  }
});

ipcMain.handle("import:json", async () => {
  const { canceled, filePaths } = await dialog.showOpenDialog({
    title: "Import from JSON",
    filters: [{ name: "JSON Files", extensions: ["json"] }],
    properties: ["openFile"],
  });
  if (canceled || filePaths.length === 0)
    return { success: false, error: "No file selected" };

  try {
    const content = await fs.promises.readFile(filePaths[0], "utf8");
    const data = JSON.parse(content);
    const txn = dbService.db.transaction(() => {
      if (data.companies) {
        const upsertV = dbService.db.prepare(`
          INSERT INTO companies (id, name, type, capacity, owner)
          VALUES (@id, @name, @type, @capacity, @owner)
          ON CONFLICT(id) DO UPDATE SET
            name=excluded.name, type=excluded.type,
            capacity=excluded.capacity, owner=excluded.owner
        `);
        data.companies.forEach((v: any) => upsertV.run(v));
      }
      if (data.users) {
        const upsertU = dbService.db.prepare(`
          INSERT INTO users (id, name, email, age, company_id)
          VALUES (@id, @name, @email, @age, @company_id)
          ON CONFLICT(id) DO UPDATE SET
            name=excluded.name, email=excluded.email,
            age=excluded.age, company_id=excluded.company_id
        `);
        data.users.forEach((u: any) => upsertU.run(u));
      }
    });
    txn();
    return { success: true };
  } catch (err: any) {
    return { success: false, error: err.message };
  }
});

ipcMain.handle("import:database", async () => {
  const { canceled, filePaths } = await dialog.showOpenDialog({
    title: "Import SQLite Database",
    filters: [{ name: "SQLite", extensions: ["sqlite", "db"] }],
    properties: ["openFile"],
  });
  if (canceled || filePaths.length === 0)
    return { success: false, error: "No file selected" };

  const src = filePaths[0];
  const dest = join(app.getPath("userData"), "app-database.sqlite");

  try {
    if (dbService.db.open) {
      dbService.db.close();
    }

    await fs.promises.copyFile(src, dest);
    await dbService.initializeDatabase();

    return { success: true };
  } catch (err: any) {
    console.error("Import DB failed:", err);
    return { success: false, error: err.message };
  }
});

ipcMain.handle("import:sql", async () => {
  const { canceled, filePaths } = await dialog.showOpenDialog({
    title: "Import from SQL File",
    filters: [{ name: "SQL Files", extensions: ["sql"] }],
    properties: ["openFile"],
  });
  if (canceled || filePaths.length === 0)
    return { success: false, error: "No file selected" };

  try {
    const sql = await fs.promises.readFile(filePaths[0], "utf8");
    dbService.db.exec(sql);
    return { success: true };
  } catch (err: any) {
    return { success: false, error: err.message };
  }
});
```

**Section sources**
- [src/main/main.ts](file://src/main/main.ts)

### æ¸²æŸ“è¿›ç¨‹åˆ†æ
æ¸²æŸ“è¿›ç¨‹è´Ÿè´£å±•ç¤ºç”¨æˆ·ç•Œé¢å’Œå¤„ç†ç”¨æˆ·äº¤äº’ã€‚æ¸²æŸ“è¿›ç¨‹é€šè¿‡ `main.ts` æ–‡ä»¶ä¸­çš„ `createApp` å‡½æ•°åˆ›å»º Vue åº”ç”¨ï¼Œå¹¶é€šè¿‡ `App.vue` æ–‡ä»¶ä¸­çš„ `App` ç»„ä»¶å±•ç¤ºä¸»ç•Œé¢ã€‚æ¸²æŸ“è¿›ç¨‹é€šè¿‡ `MulticastPage.vue` æ–‡ä»¶ä¸­çš„ `MulticastPage` ç»„ä»¶å±•ç¤ºç»„æ’­ç›‘å¬é¡µé¢ï¼Œå¹¶é€šè¿‡ `preload.ts` æ–‡ä»¶ä¸­çš„ `contextBridge` è°ƒç”¨ä¸»è¿›ç¨‹çš„ IPC æ¥å£ã€‚

#### æ¸²æŸ“è¿›ç¨‹å…¥å£æ–‡ä»¶
```typescript
import { createApp } from "vue";
import ElementPlus from "element-plus";
import "element-plus/dist/index.css";
import "./assets/css/index.css";
import App from "./App.vue";

const app = createApp(App);

app.use(ElementPlus);
app.mount("#app");
```

**Section sources**
- [src/renderer/main.ts](file://src/renderer/main.ts)

### ç»„æ’­æœåŠ¡åˆ†æ
ç»„æ’­æœåŠ¡è´Ÿè´£æ¥æ”¶å’Œè§£æç»„æ’­æ•°æ®åŒ…ã€‚ç»„æ’­æœåŠ¡é€šè¿‡ `multicast.service.ts` æ–‡ä»¶ä¸­çš„ `MulticastService` ç±»å®ç°ï¼Œä½¿ç”¨ Node.js çš„ `dgram` æ¨¡å—åˆ›å»º UDP socket ç›‘å¬ç»„æ’­æ•°æ®åŒ…ï¼Œå¹¶é€šè¿‡ IPC æœºåˆ¶å°†æ¥æ”¶åˆ°çš„æ•°æ®åŒ…ä¼ é€’ç»™æ¸²æŸ“è¿›ç¨‹ã€‚ç»„æ’­æœåŠ¡è¿˜é€šè¿‡ `protobuf-parser.service.ts` æ–‡ä»¶ä¸­çš„ `ProtobufParserService` ç±»è§£æ Protobuf æ ¼å¼çš„æ•°æ®ã€‚

#### ç»„æ’­æœåŠ¡æ–‡ä»¶
```typescript
import dgram from 'dgram';
import { EventEmitter } from 'events';
import * as dotenv from 'dotenv';
import { join } from 'path';
import { app } from 'electron';
import { protobufParserService, ParsedPacket } from './protobuf-parser.service';

// åŠ è½½ç¯å¢ƒé…ç½®
const envPath = join(app.getAppPath(), 'config.env');
dotenv.config({ path: envPath });

export interface MulticastPacket {
  timestamp: number;
  source: string;
  data: Buffer;
  dataString: string;
  size: number;
  parsedPacket?: ParsedPacket;
}

export class MulticastService extends EventEmitter {
  private socket: dgram.Socket | null = null;
  private isListening = false;
  private multicastAddress: string;
  private multicastPort: number;
  private interfaceAddress: string;

  constructor() {
    super();
    this.multicastAddress = process.env.MULTICAST_ADDRESS || '239.255.43.21';
    this.multicastPort = parseInt(process.env.MULTICAST_PORT || '10086');
    this.interfaceAddress = process.env.INTERFACE_ADDRESS || '0.0.0.0';
  }

  public start(): Promise<void> {
    return new Promise(async (resolve, reject) => {
      try {
        if (this.isListening) {
          resolve();
          return;
        }

        // åŠ è½½protobufå®šä¹‰æ–‡ä»¶
        try {
          await protobufParserService.loadProtobufDefinitions();
        } catch (error) {
          console.warn('Protobufå®šä¹‰æ–‡ä»¶åŠ è½½å¤±è´¥ï¼Œå°†ä½¿ç”¨åŸå§‹æ•°æ®æ˜¾ç¤º:', error);
        }

        this.socket = dgram.createSocket('udp4');

        this.socket.on('error', (err) => {
          console.error('ç»„æ’­ç›‘å¬é”™è¯¯:', err);
          this.emit('error', err);
        });

        this.socket.on('message', (msg, rinfo) => {
          const timestamp = Date.now();
          const source = `${rinfo.address}:${rinfo.port}`;

          // å°è¯•è§£æprotobufæ•°æ®
          let parsedPacket: ParsedPacket | undefined;
          try {
            console.log('[Multicast][è°ƒè¯•] æ”¶åˆ°æ•°æ®åŒ…:', {
              length: msg.length,
              header: msg.subarray(0, 8).toString('hex'),
              fullPacket: msg.toString('hex'),
              packageType: `0x${msg[3].toString(16).padStart(2, '0')}`,
              protocolID: `0x${msg[2].toString(16).padStart(2, '0')}`,
              dataSize: msg.length >= 8 ? msg.readUInt32LE(4) : 'N/A',
              source
            });

            const parsed = protobufParserService.parsePacket(msg, source, timestamp);
            if (parsed) {
              parsedPacket = parsed;
              // æ‰“å°ç»“æ„åŒ–æ•°æ®åˆ°åå°
              console.log('[Multicast][Protobufè§£ææˆåŠŸ] âœ…', {
                time: new Date(timestamp).toLocaleString('zh-CN'),
                source,
                packageType: parsed.packageTypeName + ` (0x${parsed.packageType.toString(16)})`,
                protocolID: `0x${parsed.protocolID.toString(16)}`,
                parsedData: parsed.parsedData,
                rawDataSize: parsed.size
              });

              // å¦‚æœæ˜¯å¹³å°çŠ¶æ€æ•°æ®ï¼Œé¢å¤–æ‰“å°è¯¦ç»†ä¿¡æ¯
              if (parsed.packageType === 0x29) {
                console.log('[Multicast][å¹³å°çŠ¶æ€è¯¦æƒ…] ğŸš', {
                  platformId: parsed.parsedData?.PlatformId,
                  platformType: parsed.parsedData?.type,
                  coordinates: parsed.parsedData?.coord,
                  timestamp: new Date(timestamp).toISOString()
                });
              }
            } else {
              console.log('[Multicast][Protobufè§£æ] âŒ è¿”å›nullï¼Œå¯èƒ½æ˜¯åŒ…æ ¼å¼ä¸åŒ¹é…');
              console.log('[Multicast][è°ƒè¯•] åŒ…å¤´æ£€æŸ¥:', {
                expectedHeader: 'aa55',
                actualHeader: msg.subarray(0, 2).toString('hex'),
                isValidHeader: msg[0] === 0xAA && msg[1] === 0x55,
                minLength: msg.length >= 8
              });
            }
          } catch (error) {
            console.error('[Multicast][Protobufè§£æå¤±è´¥] âŒ:', error);
            console.log('[Multicast][é”™è¯¯è¯¦æƒ…]', {
              errorMessage: error instanceof Error ? error.message : String(error),
              packetLength: msg.length,
              packetHex: msg.toString('hex')
            });
          }

          const packet: MulticastPacket = {
            timestamp,
            source,
            data: msg,
            dataString: msg.toString('utf8'),
            size: msg.length,
            parsedPacket
          };

          this.emit('packet', packet);
        });

        this.socket.on('listening', () => {
          console.log(`å¼€å§‹ç›‘å¬ç»„æ’­åœ°å€: ${this.multicastAddress}:${this.multicastPort}`);
          this.isListening = true;
          this.emit('started');
          resolve();
        });

        // ç»‘å®šåˆ°æŒ‡å®šç«¯å£
        this.socket.bind(this.multicastPort, this.interfaceAddress, () => {
          if (this.socket) {
            // åŠ å…¥ç»„æ’­ç»„
            this.socket.addMembership(this.multicastAddress, this.interfaceAddress);
            console.log(`å·²åŠ å…¥ç»„æ’­ç»„: ${this.multicastAddress}`);
          }
        });

      } catch (error) {
        console.error('å¯åŠ¨ç»„æ’­ç›‘å¬å¤±è´¥:', error);
        reject(error);
      }
    });
  }

  public stop(): Promise<void> {
    return new Promise((resolve) => {
      if (this.socket && this.isListening) {
        this.socket.close(() => {
          this.socket = null;
          this.isListening = false;
          console.log('ç»„æ’­ç›‘å¬å·²åœæ­¢');
          this.emit('stopped');
          resolve();
        });
      } else {
        resolve();
      }
    });
  }

  public getStatus(): { isListening: boolean; address: string; port: number } {
    return {
      isListening: this.isListening,
      address: this.multicastAddress,
      port: this.multicastPort
    };
  }

  public updateConfig(address: string, port: number, interfaceAddr: string): void {
    this.multicastAddress = address;
    this.multicastPort = port;
    this.interfaceAddress = interfaceAddr;
  }
}

export const multicastService = new MulticastService(); 
```

**Section sources**
- [src/main/services/multicast.service.ts](file://src/main/services/multicast.service.ts)

### Protobuf è§£ææœåŠ¡åˆ†æ
Protobuf è§£ææœåŠ¡è´Ÿè´£è§£æ Protobuf æ ¼å¼çš„æ•°æ®ã€‚Protobuf è§£ææœåŠ¡é€šè¿‡ `protobuf-parser.service.ts` æ–‡ä»¶ä¸­çš„ `ProtobufParserService` ç±»å®ç°ï¼Œä½¿ç”¨ `protobufjs` åº“åŠ è½½ Protobuf å®šä¹‰æ–‡ä»¶ï¼Œå¹¶è§£ææ¥æ”¶åˆ°çš„æ•°æ®åŒ…ã€‚Protobuf è§£ææœåŠ¡è¿˜é€šè¿‡ `multicast.service.ts` æ–‡ä»¶ä¸­çš„ `MulticastService` ç±»æ¥æ”¶æ•°æ®åŒ…ï¼Œå¹¶å°†è§£æç»“æœä¼ é€’ç»™æ¸²æŸ“è¿›ç¨‹ã€‚

#### Protobuf è§£ææœåŠ¡æ–‡ä»¶
```typescript
import * as protobuf from 'protobufjs';
import { join } from 'path';
import { app } from 'electron';

export interface ParsedPacket {
  timestamp: number;
  source: string;
  packageType: number;
  packageTypeName: string;
  parsedData: any;
  rawData: Buffer;
  size: number;
  protocolID: number;
}

export class ProtobufParserService {
  private root: protobuf.Root | null = null;
  private packageTypes: Map<number, string> = new Map();

  constructor() {
    this.initializePackageTypes();
  }

  private initializePackageTypes() {
    // æ ¹æ®PublicStruct.protoä¸­çš„PackageTypeæšä¸¾åˆå§‹åŒ–
    this.packageTypes.set(0x00, 'PackType_Invalid');
    this.packageTypes.set(0x01, 'PackType_Flystatus');
    this.packageTypes.set(0x02, 'PackType_HeartbeatInternal');
    this.packageTypes.set(0x03, 'PackType_SceneDataInit');
    this.packageTypes.set(0x10, 'PackType_FlyControl');
    this.packageTypes.set(0x11, 'PackType_AttitudeControl');
    this.packageTypes.set(0x12, 'PackType_EngineControl');
    this.packageTypes.set(0x13, 'PackType_DataChainControl');
    this.packageTypes.set(0x14, 'PackType_FlyControlReply');
    this.packageTypes.set(0x20, 'PackType_RouteUpload');
    this.packageTypes.set(0x21, 'PackType_SecurityBoundaryControl');
    this.packageTypes.set(0x22, 'PackType_FixedPointNavigation');
    this.packageTypes.set(0x23, 'PackType_RangePointSelect');
    this.packageTypes.set(0x24, 'PackType_NavReply');
    this.packageTypes.set(0x25, 'PackType_RouteUploadReply');
    this.packageTypes.set(0x26, 'PackType_NavModeRequest');
    this.packageTypes.set(0x27, 'PackType_PositioningModeRequest');
    this.packageTypes.set(0x28, 'PackType_RecoveryrouteCmd');
    this.packageTypes.set(0x29, 'PackType_PlatformStatus'); // æ–°å¢å¹³å°çŠ¶æ€ä¿¡æ¯
    this.packageTypes.set(0x2A, 'PackType_PlatformCmd'); // æ–°å¢å¹³å°æ§åˆ¶å‘½ä»¤
  }

  public async loadProtobufDefinitions(): Promise<void> {
    try {
      const fs = require('fs');

      // åˆ¤æ–­ç¯å¢ƒï¼Œä¼˜å…ˆå°è¯•build/main/src/protobufï¼Œå†å°è¯•src/protobuf
      const pathList = [
        join(app.getAppPath(), 'main', 'src', 'protobuf'), // ç”Ÿäº§ç¯å¢ƒæ‰“åŒ…å
        join(app.getAppPath(), 'src', 'protobuf'),        // å¼€å‘ç¯å¢ƒ
        join(process.cwd(), 'src', 'protobuf'),           // å½“å‰å·¥ä½œç›®å½•
        join(__dirname, '..', '..', 'protobuf'),          // ç›¸å¯¹äºå½“å‰æ–‡ä»¶
      ];

      let protobufPath = '';
      let found = false;

      console.log('[Protobuf] å°è¯•æŸ¥æ‰¾protobufå®šä¹‰æ–‡ä»¶...');
      for (const p of pathList) {
        console.log(`[Protobuf] æ£€æŸ¥è·¯å¾„: ${p}`);
        if (fs.existsSync(p)) {
          protobufPath = p;
          found = true;
          console.log(`[Protobuf] âœ… æ‰¾åˆ°protobufç›®å½•: ${p}`);
          break;
        }
      }

      if (!found) {
        throw new Error(`æœªæ‰¾åˆ°protobufå®šä¹‰ç›®å½•ï¼Œå·²å°è¯•è·¯å¾„: ${pathList.join(', ')}`);
      }

      // æ£€æŸ¥å¿…éœ€çš„æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼ŒåªåŠ è½½å­˜åœ¨çš„æ–‡ä»¶
      const requiredFiles = [
        'PublicStruct.proto',
        'PlatformStatus.proto',  // ä¿®æ­£æ–‡ä»¶åï¼Œå»æ‰å¤šä½™çš„ 'F'
        'PlatformCmd.proto'      // æ·»åŠ å¹³å°æ§åˆ¶å‘½ä»¤åè®®
      ];

      const availableFiles: string[] = [];
      for (const file of requiredFiles) {
        const filePath = join(protobufPath, file);
        if (fs.existsSync(filePath)) {
          availableFiles.push(filePath);
          console.log(`[Protobuf] âœ… æ‰¾åˆ°æ–‡ä»¶: ${file}`);
        } else {
          console.log(`[Protobuf] âŒ ç¼ºå°‘æ–‡ä»¶: ${file}`);
        }
      }

      if (availableFiles.length === 0) {
        throw new Error('æœªæ‰¾åˆ°ä»»ä½•protobufå®šä¹‰æ–‡ä»¶');
      }

      // åŠ è½½protobufå®šä¹‰æ–‡ä»¶
      console.log(`[Protobuf] å¼€å§‹åŠ è½½ ${availableFiles.length} ä¸ªæ–‡ä»¶...`);
      console.log(`[Protobuf] æ–‡ä»¶åˆ—è¡¨:`, availableFiles);

      this.root = await protobuf.load(availableFiles);
      console.log('[Protobuf] âœ… Protobufå®šä¹‰æ–‡ä»¶åŠ è½½æˆåŠŸï¼Œç›®å½•ï¼š', protobufPath);
      console.log('[Protobuf] å¯ç”¨çš„æ¶ˆæ¯ç±»å‹:', Object.keys(this.root.nested || {}));

      // è¯¦ç»†æ˜¾ç¤ºæ¯ä¸ªå‘½åç©ºé—´çš„å†…å®¹
      if (this.root.nested) {
        for (const [namespace, content] of Object.entries(this.root.nested)) {
          if (content instanceof protobuf.Namespace && content.nested) {
            console.log(`[Protobuf] å‘½åç©ºé—´ ${namespace}:`, Object.keys(content.nested));
          } else {
            console.log(`[Protobuf] å¯¹è±¡ ${namespace}:`, content.constructor.name);
          }
        }
      }

    } catch (error) {
      console.error('[Protobuf] âŒ åŠ è½½Protobufå®šä¹‰æ–‡ä»¶å¤±è´¥:', error);
      throw error;
    }
  }

  public parsePacket(data: Buffer, source: string, timestamp: number): ParsedPacket | null {
    try {
      if (!this.root) {
        console.warn('Protobufå®šä¹‰æ–‡ä»¶æœªåŠ è½½');
        return null;
      }

      // æ£€æŸ¥æ•°æ®åŒ…æ ¼å¼: 0xAA 0x55 + protocolID + packageType + size + protobufData
      if (data.length < 8) {
        console.warn('æ•°æ®åŒ…é•¿åº¦ä¸è¶³ï¼Œè‡³å°‘éœ€è¦8å­—èŠ‚');
        return null;
      }

      // æ£€æŸ¥åŒ…å¤´
      if (data[0] !== 0xAA || data[1] !== 0x55) {
        console.warn('æ•°æ®åŒ…åŒ…å¤´é”™è¯¯ï¼ŒæœŸæœ›0xAA 0x55');
        return null;
      }

      const protocolID = data[2];
      const packageType = data[3];
      const size = data.readUInt32LE(4); // 4å­—èŠ‚çš„protobufæ•°æ®é•¿åº¦

      console.log(`[Parser] åŒ…è§£æè¯¦æƒ…:`, {
        protocolID: `0x${protocolID.toString(16)}`,
        packageType: `0x${packageType.toString(16)}`,
        declaredSize: size,
        actualPacketLength: data.length,
        remainingBytes: data.length - 8,
        sizeBytes: data.subarray(4, 8).toString('hex')
      });

      // å¦‚æœå£°æ˜çš„å¤§å°æ˜æ˜¾é”™è¯¯ï¼Œå°è¯•ä½¿ç”¨å‰©ä½™çš„æ‰€æœ‰å­—èŠ‚
      let actualSize = size;
      if (size > data.length - 8 || size <= 0) {
        actualSize = data.length - 8;
        console.log(`[Parser] ğŸ”§ å¤§å°å­—æ®µå¼‚å¸¸ï¼Œä½¿ç”¨å‰©ä½™å­—èŠ‚æ•°: ${actualSize}`);
      }

      const messageData = data.subarray(8, 8 + actualSize); // protobufæ•°æ®

      console.log(`[Parser] æå–çš„protobufæ•°æ®:`, {
        expectedSize: size,
        actualSize: actualSize,
        extractedLength: messageData.length,
        protobufHex: messageData.toString('hex')
      });

      const packageTypeName = this.packageTypes.get(packageType) || 'Unknown';

      let parsedData: any = null;

      // æ ¹æ®åŒ…ç±»å‹è§£ææ•°æ®
      switch (packageType) {
        case 0x01: // PackType_Flystatus
          parsedData = this.parseFlyStatus(messageData);
          break;
        case 0x02: // PackType_HeartbeatInternal
          parsedData = this.parseHeartbeatInternal(messageData);
          break;
        case 0x03: // PackType_SceneDataInit
          parsedData = this.parseSceneDataInit(messageData);
          break;
        case 0x10: // PackType_FlyControl
          parsedData = this.parseFlyControl(messageData);
          break;
        case 0x11: // PackType_AttitudeControl
          parsedData = this.parseAttitudeControl(messageData);
          break;
        case 0x12: // PackType_EngineControl
          parsedData = this.parseEngineControl(messageData);
          break;
        case 0x14: // PackType_FlyControlReply
          parsedData = this.parseFlyControlReply(messageData);
          break;
        case 0x20: // PackType_RouteUpload
          parsedData = this.parseRouteUpload(messageData);
          break;
        case 0x21: // PackType_SecurityBoundaryControl
          parsedData = this.parseSecurityBoundaryControl(messageData);
          break;
        case 0x22: // PackType_FixedPointNavigation
          parsedData = this.parseFixedPointNavigation(messageData);
          break;
        case 0x23: // PackType_RangePointSelect
          parsedData = this.parseRangePointSelect(messageData);
          break;
        case 0x24: // PackType_NavReply
          parsedData = this.parseNavReply(messageData);
          break;
        case 0x25: // PackType_RouteUploadReply
          parsedData = this.parseRouteUploadReply(messageData);
          break;
        case 0x26: // PackType_NavModeRequest
          parsedData = this.parseNavModeRequest(messageData);
          break;
        case 0x27: // PackType_PositioningModeRequest
          parsedData = this.parsePositioningModeRequest(messageData);
          break;
        case 0x28: // PackType_RecoveryrouteCmd
          parsedData = this.parseRecoveryrouteCmd(messageData);
          break;
        case 0x29: // PackType_PlatformStatus
          parsedData = this.parsePlatformStatus(messageData);
          break;
        case 0x2A: // PackType_PlatformCmd
          parsedData = this.parsePlatformCmd(messageData);
          break;
        default:
          console.warn(`æœªçŸ¥çš„åŒ…ç±»å‹: 0x${packageType.toString(16)}`);
          parsedData = { raw: messageData.toString('hex') };
      }

      return {
        timestamp,
        source,
        packageType,
        packageTypeName,
        parsedData,
        rawData: data,
        size: data.length,
        protocolID: protocolID
      };

    } catch (error) {
      console.error('è§£ææ•°æ®åŒ…å¤±è´¥:', error);
      return null;
    }
  }

  private parseFlyStatus(data: Buffer): any {
    try {
      const UavFlyStatusInfo = this.root!.lookupType('UavFlyStatus.UavFlyStatusInfo');
      return UavFlyStatusInfo.decode(data);
    } catch (error) {
      console.error('è§£æé£è¡ŒçŠ¶æ€å¤±è´¥:', error);
      return { error: 'è§£æå¤±è´¥', raw: data.toString('hex') };
    }
  }

  private parsePlatformStatus(data: Buffer): any {
    try {
      console.log('[Parser] å°è¯•è§£æå¹³å°çŠ¶æ€æ•°æ®...');

      if (!this.root) {
        throw new Error('Protobuf root æœªåˆå§‹åŒ–');
      }

      // å°è¯•æŸ¥æ‰¾æ¶ˆæ¯ç±»å‹
      let PlatformsType: protobuf.Type;
      try {
        PlatformsType = this.root.lookupType('PlatformStatus.Platforms');
        console.log('[Parser] âœ… æ‰¾åˆ° PlatformStatus.Platforms ç±»å‹');
      } catch (lookupError: unknown) {
        console.log('[Parser] å°è¯•å…¶ä»–å¯èƒ½çš„ç±»å‹å...');
        // å°è¯•ä¸åŒçš„å‘½åç©ºé—´
        try {
          PlatformsType = this.root.lookupType('Platforms');
          console.log('[Parser] âœ… æ‰¾åˆ° Platforms ç±»å‹');
        } catch (e) {
          console.log('[Parser] å¯ç”¨çš„ç±»å‹:', Object.keys(this.root.nested || {}));
          const errorMessage = lookupError instanceof Error ? lookupError.message : String(lookupError);
          throw new Error(`æ— æ³•æ‰¾åˆ° PlatformStatus ç›¸å…³ç±»å‹: ${errorMessage}`);
        }
      }

      console.log('[Parser] âœ… å¼€å§‹è§£ç å¹³å°çŠ¶æ€æ•°æ®ï¼Œæ•°æ®é•¿åº¦:', data.length);
      console.log('[Parser] âœ… æ•°æ®å‰32å­—èŠ‚:', data.subarray(0, Math.min(32, data.length)).toString('hex'));
      
      const decoded = PlatformsType.decode(data);
      console.log('[Parser] âœ… å¹³å°çŠ¶æ€è§£ç æˆåŠŸ:', decoded);

      // å¦‚æœè§£ç æˆåŠŸï¼Œå°è¯•è½¬æ¢ä¸ºæ™®é€šå¯¹è±¡ä»¥ä¾¿æ›´å¥½åœ°æ˜¾ç¤º
      const decodedObject = PlatformsType.toObject(decoded, {
        longs: String,
        enums: String,
        bytes: String,
        defaults: true
      });
      
      console.log('[Parser] ğŸ“Š å¹³å°çŠ¶æ€è¯¦ç»†ä¿¡æ¯:', JSON.stringify(decodedObject, null, 2));

      return decodedObject;
    } catch (error) {
      console.error('[Parser] âŒ è§£æå¹³å°çŠ¶æ€å¤±è´¥:', error);
      return {
        error: 'è§£æå¤±è´¥',
        errorMessage: error instanceof Error ? error.message : String(error),
        raw: data.toString('hex'),
        dataLength: data.length
      };
    }
  }

  private parsePlatformCmd(data: Buffer): any {
    try {
      console.log('[Parser] å°è¯•è§£æå¹³å°æ§åˆ¶å‘½ä»¤æ•°æ®...');

      if (!this.root) {
        throw new Error('Protobuf root æœªåˆå§‹åŒ–');
      }

      // å°è¯•æŸ¥æ‰¾æ¶ˆæ¯ç±»å‹
      let PlatformCmdType: protobuf.Type;
      try {
        PlatformCmdType = this.root.lookupType('PlatformStatus.PlatformCmd');
        console.log('[Parser] âœ… æ‰¾åˆ° PlatformStatus.PlatformCmd ç±»å‹');
      } catch (lookupError: unknown) {
        console.log('[Parser] å°è¯•å…¶ä»–å¯èƒ½çš„ç±»å‹å...');
        try {
          PlatformCmdType = this.root.lookupType('PlatformCmd');
          console.log('[Parser] âœ… æ‰¾åˆ° PlatformCmd ç±»å‹');
        } catch (e) {
          console.log('[Parser] å¯ç”¨çš„ç±»å‹:', Object.keys(this.root.nested || {}));
          if (this.root.nested && this.root.nested['PlatformStatus']) {
            const platformNested = this.root.nested['PlatformStatus'] as protobuf.Namespace;
            console.log('[Parser] PlatformStatuså‘½åç©ºé—´ä¸­çš„ç±»å‹:', Object.keys(platformNested.nested || {}));
          }
          const errorMessage = lookupError instanceof Error ? lookupError.message : String(lookupError);
          throw new Error(`æ— æ³•æ‰¾åˆ° PlatformCmd ç›¸å…³ç±»å‹: ${errorMessage}`);
        }
      }

      console.log('[Parser] ğŸ” å¼€å§‹è§£ç å¹³å°æ§åˆ¶å‘½ä»¤æ•°æ®ï¼Œæ•°æ®é•¿åº¦:', data.length);
      console.log('[Parser] ğŸ” æ•°æ®å‰32å­—èŠ‚:', data.subarray(0, Math.min(32, data.length)).toString('hex'));
      
      const decoded = PlatformCmdType.decode(data);
      console.log('[Parser] âœ… å¹³å°æ§åˆ¶å‘½ä»¤è§£ç æˆåŠŸ:', decoded);

      // å¦‚æœè§£ç æˆåŠŸï¼Œå°è¯•è½¬æ¢ä¸ºæ™®é€šå¯¹è±¡ä»¥ä¾¿æ›´å¥½åœ°æ˜¾ç¤º
      const decodedObject = PlatformCmdType.toObject(decoded, {
        longs: String,
        enums: String,
        bytes: String,
        defaults: true
      });
      
      console.log('[Parser] ğŸ“Š å¹³å°æ§åˆ¶å‘½ä»¤è¯¦ç»†ä¿¡æ¯:', JSON.stringify(decodedObject, null, 2));

      return decodedObject;
    } catch (error) {
      console.error('[Parser] âŒ è§£æå¹³å°æ§åˆ¶å‘½ä»¤å¤±è´¥:', error);
      return {
        error: 'è§£æå¤±è´¥',
        errorMessage: error instanceof Error ? error.message : String(error),
        raw: data.toString('hex'),
        dataLength: data.length
      };
    }
  }

  private parseHeartbeatInternal(data: Buffer): any {
    try {
      const HeartbeatInternal = this.root!.lookupType('PublicStruct.HeartbeatInternal');
      return HeartbeatInternal.decode(data);
    } catch (error) {
      console.error('è§£æå¿ƒè·³å¤±è´¥:', error);
      return { error: 'è§£æå¤±è´¥', raw: data.toString('hex') };
    }
  }

  private parseSceneDataInit(data: Buffer): any {
    try {
      const SceneInitData = this.root!.lookupType('UaviationSimulation.SceneInitData');
      return SceneInitData.decode(data);
    } catch (error) {
      console.error('è§£æåœºæ™¯åˆå§‹åŒ–æ•°æ®å¤±è´¥:', error);
      return { error: 'è§£æå¤±è´¥', raw: data.toString('hex') };
    }
  }

  private parseFlyControl(data: Buffer): any {
    try {
      const UavFlyControlRequest = this.root!.lookupType('UavFlyMonitor.UavFlyControlRequest');
      return UavFlyControlRequest.decode(data);
    } catch (error) {
      console.error('è§£æé£è¡Œæ§åˆ¶å¤±è´¥:', error);
      return { error: 'è§£æå¤±è´¥', raw: data.toString('hex') };
    }
  }

  private parseAttitudeControl(data: Buffer): any {
    try {
      const UavAttitudeControl = this.root!.lookupType('UavFlyMonitor.UavAttitudeControl');
      return UavAttitudeControl.decode(data);
    } catch (error) {
      console.error('è§£æå§¿æ€æ§åˆ¶å¤±è´¥:', error);
      return { error: 'è§£æå¤±è´¥', raw: data.toString('hex') };
    }
  }

  private parseEngineControl(data: Buffer): any {
    try {
      const UavEngineControl = this.root!.lookupType('UavFlyMonitor.UavEngineControl');
      return UavEngineControl.decode(data);
    } catch (error) {
      console.error('è§£æå‘åŠ¨æœºæ§åˆ¶å¤±è´¥:', error);
      return { error: 'è§£æå¤±è´¥', raw: data.toString('hex') };
    }
  }

  private parseFlyControlReply(data: Buffer): any {
    try {
      const UavFlyControlReply = this.root!.lookupType('UavFlyMonitor.UavFlyControlReply');
      return UavFlyControlReply.decode(data);
    } catch (error) {
      console.error('è§£æé£è¡Œæ§åˆ¶å›å¤å¤±è´¥:', error);
      return { error: 'è§£æå¤±è´¥', raw: data.toString('hex') };
    }
  }

  private parseRouteUpload(data: Buffer): any {
    try {
      const UavRouteUpload = this.root!.lookupType('UavNavMonitor.UavRouteUpload');
      return UavRouteUpload.decode(data);
    } catch (error) {
      console.error('è§£æèˆªçº¿ä¸Šä¼ å¤±è´¥:', error);
      return { error: 'è§£æå¤±è´¥', raw: data.toString('hex') };
    }
  }

  private parseSecurityBoundaryControl(data: Buffer): any {
    try {
      const UavSecurityBoundaryControl = this.root!.lookupType('UavNavMonitor.UavSecurityBoundaryControl');
      return UavSecurityBoundaryControl.decode(data);
    } catch (error) {
      console.error('è§£æå®‰å…¨è¾¹ç•Œæ§åˆ¶å¤±è´¥:', error);
      return { error: 'è§£æå¤±è´¥', raw: data.toString('hex') };
    }
  }

  private parseFixedPointNavigation(data: Buffer): any {
    try {
      const UavFixedPointNavigation = this.root!.lookupType('UavNavMonitor.UavFixedPointNavigation');
      return UavFixedPointNavigation.decode(data);
    } catch (error) {
      console.error('è§£æå®šç‚¹å¯¼èˆªå¤±è´¥:', error);
      return { error: 'è§£æå¤±è´¥', raw: data.toString('hex') };
    }
  }

  private parseRangePointSelect(data: Buffer): any {
    try {
      const UavRangePointSelect = this.root!.lookupType('UavNavMonitor.UavRangePointSelect');
      return UavRangePointSelect.decode(data);
    } catch (error) {
      console.error('è§£æé¶åœºç‚¹é€‰æ‹©å¤±è´¥:', error);
      return { error: 'è§£æå¤±è´¥', raw: data.toString('hex') };
    }
  }

  private parseNavReply(data: Buffer): any {
    try {
      const UavNavReplyInfo = this.root!.lookupType('UavNavMonitor.UavNavReplyInfo');
      return UavNavReplyInfo.decode(data);
    } catch (error) {
      console.error('è§£æå¯¼èˆªå›å¤å¤±è´¥:', error);
      return { error: 'è§£æå¤±è´¥', raw: data.toString('hex') };
    }
  }

  private parseRouteUploadReply(data: Buffer): any {
    try {
      const UavRouteUploadReply = this.root!.lookupType('UavNavMonitor.UavRouteUploadReply');
      return UavRouteUploadReply.decode(data);
    } catch (error) {
      console.error('è§£æèˆªçº¿ä¸Šä¼ å›å¤å¤±è´¥:', error);
      return { error: 'è§£æå¤±è´¥', raw: data.toString('hex') };
    }
  }

  private parseNavModeRequest(data: Buffer): any {
    try {
      const UavNavModeRequest = this.root!.lookupType('UavNavMonitor.UavNavModeRequest');
      return UavNavModeRequest.decode(data);
    } catch (error) {
      console.error('è§£æå¯¼èˆªæ¨¡å¼è¯·æ±‚å¤±è´¥:', error);
      return { error: 'è§£æå¤±è´¥', raw: data.toString('hex') };
    }
  }

  private parsePositioningModeRequest(data: Buffer): any {
    try {
      const UavPositioningModeRequest = this.root!.lookupType('UavNavMonitor.UavPositioningModeRequest');
      return UavPositioningModeRequest.decode(data);
    } catch (error) {
      console.error('è§£æå®šä½æ¨¡å¼è¯·æ±‚å¤±è´¥:', error);
      return { error: 'è§£æå¤±è´¥', raw: data.toString('hex') };
    }
  }

  private parseRecoveryrouteCmd(data: Buffer): any {
    try {
      const UavRecoveryrouteCmd = this.root!.lookupType('UavNavMonitor.UavRecoveryrouteCmd');
      return UavRecoveryrouteCmd.decode(data);
    } catch (error) {
      console.error('è§£æå›æ”¶èˆªçº¿å‘½ä»¤å¤±è´¥:', error);
      return { error: 'è§£æå¤±è´¥', raw: data.toString('hex') };
    }
  }

  public getPackageTypeName(packageType: number): string {
    return this.packageTypes.get(packageType) || 'Unknown';
  }

  public getAllPackageTypes(): Map<number, string> {
    return new Map(this.packageTypes);
  }
}

export const protobufParserService = new ProtobufParserService(); 
```

**Section sources**
- [src/main/services/protobuf-parser.service.ts](file://src/main/services/protobuf-parser.service.ts)

### æ•°æ®åº“æœåŠ¡åˆ†æ
æ•°æ®åº“æœåŠ¡è´Ÿè´£æ•°æ®çš„æŒä¹…åŒ–å­˜å‚¨ã€‚æ•°æ®åº“æœåŠ¡é€šè¿‡ `db.service.ts` æ–‡ä»¶ä¸­çš„ `DBService` ç±»å®ç°ï¼Œä½¿ç”¨ `better-sqlite3` åº“ç®¡ç† SQLite æ•°æ®åº“ã€‚æ•°æ®åº“æœåŠ¡è¿˜é€šè¿‡ `main.ts` æ–‡ä»¶ä¸­çš„ `dbService` å®ä¾‹ç®¡ç†æ•°æ®åº“çš„è¿ç§»å’Œç§å­æ•°æ®ã€‚

#### æ•°æ®åº“æœåŠ¡æ–‡ä»¶
```typescript
import Database from "better-sqlite3";
import { app } from "electron";
import path from "path";
import fs from "fs";

class DBService {
  private dbInstance: Database.Database;
  private migrationsPath = path.join(__dirname, "migrations");
  private seedsPath = path.join(__dirname, "seeds");

  constructor() {
    this.initializeDatabase();
    this.applyMigrations();
    this.runSeeds();
  }

  private getDatabasePath() {
    return path.join(app.getPath("userData"), "app-database.sqlite");
  }

  private getAppliedVersions(tableName: string) {
    this.dbInstance.exec(`
      CREATE TABLE IF NOT EXISTS ${tableName} (
        version TEXT PRIMARY KEY,
        applied_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `);

    return this.dbInstance
      .prepare(`SELECT version FROM ${tableName} ORDER BY version DESC`)
      .all()
      .map((row) => row.version);
  }

  private async processFiles(
    dirPath: string,
    tableName: string,
    executor: (filePath: string) => void
  ) {
    const files = fs
      .readdirSync(dirPath)
      .filter((file) => file.endsWith(".js"))
      .sort();

    const applied = this.getAppliedVersions(tableName);

    for (const file of files) {
      const version = file.split("-")[0];
      if (applied.includes(version)) continue;

      const filePath = path.join(dirPath, file);
      await executor(filePath);

      this.dbInstance
        .prepare(`INSERT INTO ${tableName} (version) VALUES (?)`)
        .run(version);
    }
  }

  public initializeDatabase() {
    this.dbInstance = new Database(this.getDatabasePath());
    this.dbInstance.pragma("journal_mode = WAL");
    this.dbInstance.pragma("foreign_keys = ON");
  }

  public async applyMigrations() {
    await this.processFiles(
      this.migrationsPath,
      "schema_migrations",
      async (filePath) => {
        const migration = require(filePath);
        const transaction = this.dbInstance.transaction(() => {
          migration.up(this.dbInstance);
        });
        transaction();
      }
    );
  }

  public async runSeeds() {
    await this.processFiles(this.seedsPath, "data_seeds", async (filePath) => {
      const seed = require(filePath);
      const transaction = this.dbInstance.transaction(() => {
        seed.run(this.dbInstance);
      });
      transaction();
    });
  }

  public get db() {
    return this.dbInstance;
  }
}

export const dbService = new DBService();
```

**Section sources**
- [src/main/database/db.service.ts](file://src/main/database/db.service.ts)

### ç»„æ’­å‘é€æœåŠ¡åˆ†æ
ç»„æ’­å‘é€æœåŠ¡è´Ÿè´£å‘é€æ§åˆ¶å‘½ä»¤æ•°æ®åŒ…ã€‚è¯¥æœåŠ¡é€šè¿‡ `multicast-sender.service.ts` æ–‡ä»¶ä¸­çš„ `MulticastSenderService` ç±»å®ç°ï¼Œä½¿ç”¨ Node.js çš„ `dgram` æ¨¡å—åˆ›å»º UDP socket å‘é€ç»„æ’­æ•°æ®åŒ…ã€‚æœåŠ¡æ”¯æŒå‘é€ PlatformCmd æ ¼å¼çš„æ§åˆ¶å‘½ä»¤ï¼Œå¹¶é€šè¿‡ IPC æœºåˆ¶ä¸æ¸²æŸ“è¿›ç¨‹é€šä¿¡ã€‚

#### ç»„æ’­å‘é€æœåŠ¡æ–‡ä»¶
```typescript
import dgram from 'dgram';
import * as protobuf from 'protobufjs';
import { join } from 'path';
import { app } from 'electron';

export interface PlatformCmdData {
  commandID: number;
  platformName: string;
  platformType: string;
  command: number; // PlatformCommand æšä¸¾å€¼
  fireParam?: {
    weaponName?: string;
    targetName?: string;
    quantity?: number;
  };
}

export class MulticastSenderService {
  private socket: dgram.Socket | null = null;
  private root: protobuf.Root | null = null;
  private multicastAddress: string;
  private multicastPort: number;

  constructor() {
    this.multicastAddress = process.env.MULTICAST_ADDRESS || '239.255.43.21';
    this.multicastPort = parseInt(process.env.MULTICAST_PORT || '10086');
  }

  public isInitialized(): boolean {
    return this.root !== null && this.socket !== null;
  }

  public async initialize(): Promise<void> {
    try {
      // åˆ›å»ºUDP socket
      this.socket = dgram.createSocket('udp4');

      // åŠ è½½protobufå®šä¹‰æ–‡ä»¶
      await this.loadProtobufDefinitions();

      console.log('[MulticastSender] ç»„æ’­å‘é€æœåŠ¡åˆå§‹åŒ–æˆåŠŸ');
    } catch (error) {
      console.error('[MulticastSender] åˆå§‹åŒ–å¤±è´¥:', error);
      throw error;
    }
  }

  private async loadProtobufDefinitions(): Promise<void> {
    try {
      const fs = require('fs');

      // æ‰©å±•è·¯å¾„åˆ—è¡¨ï¼Œå¤„ç†å„ç§å¯èƒ½çš„ç¯å¢ƒ
      const pathList: string[] = [];
      
      // å°è¯•è·å– app è·¯å¾„ï¼Œå¤„ç†å¯èƒ½çš„å¼‚å¸¸
      try {
        const appPath = app.getAppPath();
        pathList.push(
          join(appPath, 'main', 'src', 'protobuf'), // ç”Ÿäº§ç¯å¢ƒæ‰“åŒ…å
          join(appPath, 'src', 'protobuf'),        // å¼€å‘ç¯å¢ƒ
          join(appPath, 'build', 'main', 'src', 'protobuf'), // ç¼–è¯‘åè·¯å¾„
          join(appPath, 'resources', 'app', 'src', 'protobuf') // æ‰“åŒ…åçš„èµ„æºè·¯å¾„
        );
      } catch (appError) {
        console.log('[MulticastSender] âš ï¸ æ— æ³•è·å–appè·¯å¾„ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆ');
      }
      
      // æ·»åŠ é€šç”¨è·¯å¾„
      pathList.push(
        join(process.cwd(), 'src', 'protobuf'),           // å½“å‰å·¥ä½œç›®å½•
        join(__dirname, '..', '..', 'protobuf'),          // ç›¸å¯¹äºå½“å‰æ–‡ä»¶
        join(__dirname, '..', 'protobuf'),                // å¤‡ç”¨è·¯å¾„1
        join(__dirname, 'protobuf'),                      // å¤‡ç”¨è·¯å¾„2
        join(__dirname, '../../src/protobuf'),            // ä»buildç›®å½•å‘ä¸ŠæŸ¥æ‰¾
        join(process.cwd(), 'build', 'main', 'src', 'protobuf'), // ç¼–è¯‘åçš„è·¯å¾„
        'src/protobuf'    // ç»å¯¹è·¯å¾„ä½œä¸ºæœ€åå¤‡é€‰
      );

      let protobufPath = '';
      let found = false;

      console.log('[MulticastSender] å°è¯•æŸ¥æ‰¾protobufå®šä¹‰æ–‡ä»¶...');
      for (const p of pathList) {
        console.log(`[MulticastSender] æ£€æŸ¥è·¯å¾„: ${p}`);
        try {
          if (fs.existsSync(p)) {
            protobufPath = p;
            found = true;
            console.log(`[MulticastSender] âœ… æ‰¾åˆ°protobufç›®å½•: ${p}`);
            break;
          }
        } catch (pathError) {
          console.log(`[MulticastSender] âš ï¸ è·¯å¾„æ£€æŸ¥å¤±è´¥: ${p}`);
        }
      }

      if (!found) {
        throw new Error(`æœªæ‰¾åˆ°protobufå®šä¹‰ç›®å½•ï¼Œå·²å°è¯• ${pathList.length} ä¸ªè·¯å¾„: ${pathList.slice(0, 5).join(', ')}...`);
      }

      // åŠ è½½ PlatformCmd ç›¸å…³çš„protobufå®šä¹‰
      const requiredFiles = ['PublicStruct.proto', 'PlatformCmd.proto'];
      const availableFiles: string[] = [];

      for (const file of requiredFiles) {
        const filePath = join(protobufPath, file);
        try {
          if (fs.existsSync(filePath)) {
            availableFiles.push(filePath);
            console.log(`[MulticastSender] âœ… æ‰¾åˆ°æ–‡ä»¶: ${file}`);
          } else {
            console.log(`[MulticastSender] âŒ ç¼ºå°‘æ–‡ä»¶: ${file} (è·¯å¾„: ${filePath})`);
          }
        } catch (fileError) {
          console.log(`[MulticastSender] âš ï¸ æ£€æŸ¥æ–‡ä»¶å¤±è´¥: ${file} - ${fileError}`);
        }
      }

      if (availableFiles.length === 0) {
        throw new Error(`ç¼ºå°‘å¿…éœ€çš„protobufæ–‡ä»¶ï¼Œéœ€è¦: ${requiredFiles.join(', ')}ï¼Œå·²æœç´¢ç›®å½•: ${protobufPath}`);
      }

      console.log(`[MulticastSender] å¼€å§‹åŠ è½½ ${availableFiles.length} ä¸ªprotobufæ–‡ä»¶...`);
      console.log(`[MulticastSender] æ–‡ä»¶åˆ—è¡¨: ${availableFiles.map(f => require('path').basename(f)).join(', ')}`);
      
      this.root = await protobuf.load(availableFiles);
      console.log('[MulticastSender] âœ… Protobufå®šä¹‰æ–‡ä»¶åŠ è½½æˆåŠŸ');
      
      // éªŒè¯å¿…è¦çš„æ¶ˆæ¯ç±»å‹æ˜¯å¦å­˜åœ¨
      try {
        const PlatformCmdType = this.root.lookupType('PlatformStatus.PlatformCmd');
        const FireParamType = this.root.lookupType('PlatformStatus.FireParam');
        console.log('[MulticastSender] âœ… éªŒè¯æ¶ˆæ¯ç±»å‹æˆåŠŸ');
      } catch (verifyError) {
        console.error('[MulticastSender] âŒ æ¶ˆæ¯ç±»å‹éªŒè¯å¤±è´¥:', verifyError);
        if (this.root && this.root.nested) {
          console.log('[MulticastSender] å¯ç”¨çš„å‘½åç©ºé—´:', Object.keys(this.root.nested));
          if (this.root.nested['PlatformStatus']) {
            const platformNested = this.root.nested['PlatformStatus'] as protobuf.Namespace;
            console.log('[MulticastSender] PlatformStatuså‘½åç©ºé—´ä¸­çš„ç±»å‹:', Object.keys(platformNested.nested || {}));
          }
        }
        throw verifyError;
      }
    } catch (error) {
      console.error('[MulticastSender] âŒ åŠ è½½Protobufå®šä¹‰æ–‡ä»¶å¤±è´¥:', error);
      throw error;
    }
  }

  public async sendPlatformCmd(data: PlatformCmdData): Promise<void> {
    try {
      if (!this.root) {
        throw new Error('Protobufå®šä¹‰æ–‡ä»¶æœªåŠ è½½ï¼Œè¯·å…ˆè°ƒç”¨ initialize() æ–¹æ³•');
      }

      if (!this.socket) {
        throw new Error('UDP socketæœªåˆå§‹åŒ–ï¼Œè¯·å…ˆè°ƒç”¨ initialize() æ–¹æ³•');
      }

      // æŸ¥æ‰¾æ¶ˆæ¯ç±»å‹
      const PlatformCmdType = this.root.lookupType('PlatformStatus.PlatformCmd');
      const FireParamType = this.root.lookupType('PlatformStatus.FireParam');

      console.log('[MulticastSender] åˆ›å»ºPlatformCmdæ¶ˆæ¯:', data);

      // åˆ›å»ºæ¶ˆæ¯æ•°æ®
      const cmdData: any = {
        commandID: data.commandID,
        platformName: data.platformName,
        platformType: data.platformType,
        command: data.command
      };

      // å¦‚æœæœ‰fireParamï¼Œæ·»åŠ åˆ°æ¶ˆæ¯ä¸­
      if (data.fireParam) {
        const fireParam = FireParamType.create({
          weaponName: data.fireParam.weaponName || '',
          targetName: data.fireParam.targetName || '',
          quantity: data.fireParam.quantity || 1
        });
        cmdData.fireParam = fireParam;
      }

      // åˆ›å»ºå¹¶ç¼–ç protobufæ¶ˆæ¯
      const message = PlatformCmdType.create(cmdData);
      const protobufBuffer = PlatformCmdType.encode(message).finish();

      console.log('[MulticastSender] Protobufç¼–ç åå¤§å°:', protobufBuffer.length, 'å­—èŠ‚');

      // æ„é€ å®Œæ•´çš„æ•°æ®åŒ…: 0xAA 0x55 + protocolID + packageType + size + protobufData
      const protocolID = 0x01; // åè®®ID
      const packageType = 0x2A; // PackType_PlatformCmd
      const size = protobufBuffer.length;

      // åˆ›å»ºåŒ…å¤´
      const header = Buffer.alloc(8);
      header[0] = 0xAA; // åŒ…å¤´æ ‡è¯†
      header[1] = 0x55; // åŒ…å¤´æ ‡è¯†
      header[2] = protocolID; // åè®®ID
      header[3] = packageType; // åŒ…ç±»å‹
      header.writeUInt32LE(size, 4); // protobufæ•°æ®é•¿åº¦ï¼ˆå°ç«¯åºï¼‰

      // ç»„åˆå®Œæ•´æ•°æ®åŒ…
      const fullPacket = Buffer.concat([header, protobufBuffer]);

      console.log('[MulticastSender] æ•°æ®åŒ…æ„é€ è¯¦æƒ…:', {
        æ€»é•¿åº¦: fullPacket.length,
        åŒ…å¤´: header.toString('hex'),
        åè®®ID: `0x${protocolID.toString(16)}`,
        åŒ…ç±»å‹: `0x${packageType.toString(16)}`,
        å£°æ˜å¤§å°: size,
        å®é™…protobufå¤§å°: protobufBuffer.length
      });

      // å‘é€æ•°æ®åŒ…
      await this.sendPacket(fullPacket);

      console.log('[MulticastSender] âœ… PlatformCmdæ¶ˆæ¯å‘é€æˆåŠŸ');
    } catch (error) {
      console.error('[MulticastSender] âŒ å‘é€PlatformCmdæ¶ˆæ¯å¤±è´¥:', error);
      throw error;
    }
  }

  private sendPacket(packet: Buffer): Promise<void> {
    return new Promise((resolve, reject) => {
      if (!this.socket) {
        reject(new Error('UDP socketæœªåˆå§‹åŒ–'));
        return;
      }

      this.socket.send(packet, this.multicastPort, this.multicastAddress, (err) => {
        if (err) {
          reject(err);
        } else {
          console.log(`[MulticastSender] å·²å‘é€æ•°æ®åŒ…åˆ° ${this.multicastAddress}:${this.multicastPort}`);
          console.log(`[MulticastSender] æ•°æ®åŒ…å¤§å°: ${packet.length} å­—èŠ‚`);
          console.log(`[MulticastSender] å‘é€æ—¶é—´: ${new Date().toLocaleString('zh-CN')}`);
          resolve();
        }
      });
    });
  }

  public close(): void {
    if (this.socket) {
      this.socket.close();
      this.socket = null;
      console.log('[MulticastSender] UDP socketå·²å…³é—­');
    }
  }
}

export const multicastSenderService = new MulticastSenderService();
```

**Section sources**
- [src/main/services/multicast-sender.service.ts](file://src/main/services/multicast-sender.service.ts)

### ç«ç‚®æ“ä½œé¡µé¢åˆ†æ
ç«ç‚®æ“ä½œé¡µé¢è´Ÿè´£æä¾›ç”¨æˆ·å‹å¥½çš„ç«ç‚®æ§åˆ¶ç•Œé¢ã€‚è¯¥é¡µé¢é€šè¿‡ `ArtilleryOperationPage.vue` æ–‡ä»¶ä¸­çš„ `ArtilleryOperationPage` ç»„ä»¶å®ç°ï¼Œä½¿ç”¨ Vue 3 å’Œ Element Plus æ„å»ºç”¨æˆ·ç•Œé¢ã€‚é¡µé¢é€šè¿‡ `preload.ts` æ–‡ä»¶ä¸­çš„ `contextBridge` è°ƒç”¨ä¸»è¿›ç¨‹çš„ IPC æ¥å£ï¼Œå‘é€ç«ç‚®æ§åˆ¶å‘½ä»¤ã€‚

#### ç«ç‚®æ“ä½œé¡µé¢ç»„ä»¶
```vue
<template>
  <div class="flex flex-col h-full p-4">
    <!-- è¿æ¥é…ç½®åŒºåŸŸ -->
    <div class="bg-white rounded-lg shadow-md p-6 mb-4">
      <h2 class="text-xl font-semibold mb-4">è¿æ¥é…ç½®</h2>
      <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
        <el-form-item label="é€‰æ‹©ç»„">
          <el-select v-model="selectedGroup" placeholder="é€‰æ‹©ç»„" style="width: 100%">
            <el-option label="ç¬¬ä¸€ç»„" value="group1" />
            <el-option label="ç¬¬äºŒç»„" value="group2" />
          </el-select>
        </el-form-item>
        <el-form-item label="å®ä¾‹">
          <el-select v-model="selectedInstance" placeholder="é€‰æ‹©å®ä¾‹" style="width: 100%">
            <el-option label="ç«ç‚®1" value="artillery1" />
            <el-option label="ç«ç‚®2" value="artillery2" />
          </el-select>
        </el-form-item>
        <el-form-item label="æ“ä½œäºº">
          <el-input v-model="operatorName" placeholder="è¾“å…¥æ“ä½œäººå§“å" />
        </el-form-item>
        <div class="flex items-end">
          <el-button 
            type="primary" 
            @click="connectToSimulation"
            :loading="connecting"
            class="w-full"
          >
            {{ connectionStatus.isConnected ? 'å·²è¿æ¥' : 'è¿æ¥ä»¿çœŸç«¯' }}
          </el-button>
        </div>
      </div>
    </div>

    <!-- ä¸­é—´æ“ä½œåŒºåŸŸ -->
    <div class="flex gap-4 flex-1">
      <!-- å·¦ä¾§æ“ä½œé¢æ¿ -->
      <div class="w-1/2 flex flex-col gap-4">
        <!-- è£…å¡«å¼¹è¯æ“ä½œ -->
        <div class="bg-white rounded-lg shadow-md p-6">
          <h3 class="text-lg font-semibold mb-4 text-gray-800">è£…å¡«-ç©¿ç”²å¼¹</h3>
          <div class="space-y-4">
            <div class="grid grid-cols-2 gap-4">
              <div class="text-center">
                <div class="text-xl font-bold text-blue-600">{{ ammunitionCount }}</div>
                <div class="text-sm text-gray-500">å¼¹è¯æ•°é‡</div>
              </div>
              <div class="text-center">
                <div class="text-xl font-bold" :class="artilleryStatus.isLoaded ? 'text-green-600' : 'text-orange-600'">
                  {{ artilleryStatus.isLoaded ? 'å·²è£…å¡«' : 'æœªè£…å¡«' }}
                </div>
                <div class="text-sm text-gray-500">è£…å¡«çŠ¶æ€</div>
              </div>
            </div>
            <el-button 
              type="primary" 
              @click="loadAmmunition" 
              class="w-full" 
              size="large"
              :disabled="!connectionStatus.isConnected || artilleryStatus.isLoaded"
            >
              è£…å¡«å¼¹è¯
            </el-button>
          </div>
        </div>

        <!-- å‘å°„æ“ä½œ -->
        <div class="bg-white rounded-lg shadow-md p-6">
          <h3 class="text-lg font-semibold mb-4 text-gray-800">å‘å°„ (å‘å°„åè‡ªåŠ¨å‘å°„é˜²ç©ºæŠ¥æ–‡ç»™æ— äººæœº)</h3>
          <div class="space-y-4">
            <!-- æ­¦å™¨å’Œç›®æ ‡è¾“å…¥æ¡† -->
            <div class="grid grid-cols-2 gap-3">
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">æ­¦å™¨åç§°</label>
                <el-input 
                  v-model="weaponName" 
                  placeholder="è¾“å…¥æ­¦å™¨åç§°"
                  size="small"
                />
              </div>
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">ç›®æ ‡åç§°</label>
                <el-input 
                  v-model="targetName" 
                  placeholder="è¾“å…¥ç›®æ ‡åç§°"
                  size="small"
                />
              </div>
            </div>
            
            <div class="text-center p-4 bg-gray-50 rounded">
              <div class="text-sm text-gray-600 mb-2">ç›®æ ‡: æ— äººæœºç¼–å· {{ targetDroneId }}</div>
              <div class="text-sm text-gray-600">çŠ¶æ€: {{ fireStatus }}</div>
            </div>
            <el-button 
              type="danger" 
              @click="fireAtDrone" 
              class="w-full" 
              size="large"
              :disabled="!connectionStatus.isConnected || !artilleryStatus.isLoaded || !weaponName || !targetName"
            >
              å‘å°„
            </el-button>
          </div>
        </div>
      </div>

      <!-- å³ä¾§çŠ¶æ€é¢æ¿ -->
      <div class="w-1/2 bg-white rounded-lg shadow-md p-6">
        <h3 class="text-lg font-semibold mb-4 text-gray-800">çŠ¶æ€é¢æ¿</h3>
        <div class="space-y-4">
          <div class="p-4 bg-gray-50 rounded">
            <div class="text-sm font-semibold text-gray-700 mb-2">ç¯å¢ƒçŠ¶æ€</div>
            <div class="text-sm text-gray-600 space-y-1">
              <div>æ¸©åº¦: {{ environment.temperature }}Â°C</div>
              <div>æ¹¿åº¦: {{ environment.humidity }}%</div>
              <div>é£é€Ÿ: {{ environment.windSpeed }}m/s</div>
              <div>èƒ½è§åº¦: {{ environment.visibility }}km</div>
            </div>
          </div>
          
          <div class="p-4 bg-gray-50 rounded">
            <div class="text-sm font-semibold text-gray-700 mb-2">ç›®æ ‡çŠ¶æ€</div>
            <div class="text-sm text-gray-600 space-y-1">
              <div>ç›®æ ‡ç±»å‹: {{ targetInfo.type }}</div>
              <div>è·ç¦»: {{ targetInfo.distance }}m</div>
              <div>æ–¹ä½: {{ targetInfo.bearing }}Â°</div>
              <div>é«˜åº¦: {{ targetInfo.altitude }}m</div>
            </div>
          </div>
          
          <div class="p-4 bg-gray-50 rounded">
            <div class="text-sm font-semibold text-gray-700 mb-2">ç«ç‚®çŠ¶æ€</div>
            <div class="text-sm text-gray-600 space-y-1">
              <div>ç‚®ç®¡æ¸©åº¦: {{ artilleryStatus.temperature }}Â°C</div>
              <div>å°„å‡»å‡†å¤‡: {{ artilleryStatus.isReady ? 'å°±ç»ª' : 'æœªå°±ç»ª' }}</div>
              <div>ç³»ç»ŸçŠ¶æ€: {{ artilleryStatus.systemStatus }}</div>
            </div>
          </div>
          
          <div class="p-4 bg-gray-50 rounded">
            <div class="text-sm font-semibold text-gray-700 mb-2">æ— äººæœºæ‰“å‡»ååŒçŠ¶æ€</div>
            <div class="text-sm text-gray-600 space-y-1">
              <div>ååŒæ¨¡å¼: {{ coordinationStatus.mode }}</div>
              <div>æ•°æ®é“¾çŠ¶æ€: {{ coordinationStatus.dataLink }}</div>
              <div>ç›®æ ‡å…±äº«: {{ coordinationStatus.targetSharing }}</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- åº•éƒ¨æ–‡æ¡£æµè§ˆåŒºåŸŸ -->
    <div class="bg-white rounded-lg shadow-md p-6" style="height: 200px;">
      <div class="flex items-center justify-between mb-4">
        <h3 class="text-lg font-semibold text-gray-800">ä»»åŠ¡æ–‡æ¡£</h3>
        <el-button @click="openDocument" size="small">
          æ‰“å¼€æ–‡æ¡£
        </el-button>
      </div>
      <div class="h-32 border-2 border-dashed border-gray-300 rounded-lg flex items-center justify-center">
        <div class="text-center text-gray-500">
          <div class="text-4xl mb-2">ğŸ“„</div>
          <div class="text-lg">å±•ç¤ºæ–‡æ¡£å†…å®¹ (æ”¯æŒdoc, docxæ ¼å¼)</div>
          <div class="text-sm">ç‚¹å‡»"æ‰“å¼€æ–‡æ¡£"æµè§ˆä»»åŠ¡ç›¸å…³æ–‡ä»¶</div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, reactive } from 'vue';
import { ElMessage } from 'element-plus';

// è¿æ¥çŠ¶æ€æ¥å£
interface ConnectionStatus {
  isConnected: boolean;
  simulationEndpoint: string;
}

// ç«ç‚®çŠ¶æ€æ¥å£
interface ArtilleryStatus {
  isReady: boolean;
  isLoaded: boolean;
  temperature: number;
  systemStatus: string;
}

// ç›®æ ‡ä¿¡æ¯æ¥å£
interface TargetInfo {
  type: string;
  distance: number;
  bearing: number;
  altitude: number;
}

// ç¯å¢ƒçŠ¶æ€æ¥å£
interface Environment {
  temperature: number;
  humidity: number;
  windSpeed: number;
  visibility: number;
}

// ååŒçŠ¶æ€æ¥å£
interface CoordinationStatus {
  mode: string;
  dataLink: string;
  targetSharing: string;
}

// å“åº”å¼æ•°æ®
const selectedGroup = ref('group1');
const selectedInstance = ref('artillery1');
const operatorName = ref('');
const ammunitionCount = ref(12);
const targetDroneId = ref('UAV-001');
const fireStatus = ref('å¾…å‘å°„');
const weaponName = ref('155æ¯«ç±³æ¦†å¼¹ç‚®'); // æ­¦å™¨åç§°ï¼Œé»˜è®¤å€¼
const targetName = ref('æ— äººæœº-001'); // ç›®æ ‡åç§°ï¼Œé»˜è®¤å€¼

const connectionStatus = reactive<ConnectionStatus>({
  isConnected: false,
  simulationEndpoint: ''
});

const artilleryStatus = reactive<ArtilleryStatus>({
  isReady: false,
  isLoaded: false,
  temperature: 32,
  systemStatus: 'æ­£å¸¸'
});

const targetInfo = reactive<TargetInfo>({
  type: 'æ— äººæœº',
  distance: 3200,
  bearing: 45,
  altitude: 1200
});

const environment = reactive<Environment>({
  temperature: 25,
  humidity: 65,
  windSpeed: 3.2,
  visibility: 12
});

const coordinationStatus = reactive<CoordinationStatus>({
  mode: 'è‡ªä¸»ååŒ',
  dataLink: 'æ­£å¸¸',
  targetSharing: 'å·²å…±äº«'
});

// è¿æ¥ä»¿çœŸç«¯
const connectToSimulation = async () => {
  // æ¨¡æ‹Ÿè¿æ¥è¿‡ç¨‹
  connecting.value = true;
  try {
    // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    connectionStatus.isConnected = true;
    connectionStatus.simulationEndpoint = `ws://${selectedGroup.value}.${selectedInstance.value}.simulation`;
    
    ElMessage.success(`æˆåŠŸè¿æ¥åˆ° ${selectedGroup.value} - ${selectedInstance.value}`);
    
    // æ¨¡æ‹ŸçŠ¶æ€æ›´æ–°
    artilleryStatus.isReady = true;
  } catch (error) {
    ElMessage.error('è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè®¾ç½®');
  } finally {
    connecting.value = false;
  }
};

// è£…å¡«å¼¹è¯
const loadAmmunition = async () => {
  try {
    // æ¨¡æ‹Ÿè£…å¡«è¿‡ç¨‹
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    if (ammunitionCount.value > 0) {
      artilleryStatus.isLoaded = true;
      ammunitionCount.value--;
      ElMessage.success('å¼¹è¯è£…å¡«å®Œæˆ');
    } else {
      ElMessage.warning('å¼¹è¯ä¸è¶³ï¼Œè¯·è¡¥å……å¼¹è¯');
    }
  } catch (error) {
    ElMessage.error('è£…å¡«å¤±è´¥');
  }
};

// å‘å°„æ“ä½œ
const fireAtDrone = async () => {
  try {
    if (!weaponName.value.trim() || !targetName.value.trim()) {
      ElMessage.warning('è¯·å¡«å†™æ­¦å™¨åç§°å’Œç›®æ ‡åç§°');
      return;
    }
    
    ElMessage.success(`å‘ç›®æ ‡ ${targetName.value} å‘å°„ ${weaponName.value}`);
    artilleryStatus.isLoaded = false;
    fireStatus.value = 'å‘å°„ä¸­...';
    
    // æ„é€  PlatformCmd æ•°æ®
    const platformCmdData = {
      commandID: Date.now(), // ä½¿ç”¨æ—¶é—´æˆ³ä½œä¸ºå‘½ä»¤ID
      platformName: selectedInstance.value || 'artillery1', // å¹³å°åç§°
      platformType: 'Artillery', // å¹³å°ç±»å‹
      command: 10, // Arty_Fire = 10 (æ ¹æ® PlatformCmd.proto)
      fireParam: {
        weaponName: weaponName.value.trim(),
        targetName: targetName.value.trim(),
        quantity: 1
      }
    };

    console.log('å‘é€ PlatformCmd æ•°æ®:', platformCmdData);
    
    // å‘é€ PlatformCmd ç»„æ’­æ¶ˆæ¯
    const result = await (window as any).electronAPI.multicast.sendPlatformCmd(platformCmdData);
    
    if (result.success) {
      ElMessage.success('ğŸš€ ç«ç‚®æ§åˆ¶å‘½ä»¤å‘é€æˆåŠŸ');
      fireStatus.value = 'å·²å‘å°„';
      
      // æ¨¡æ‹Ÿå‘å°„åè‡ªåŠ¨å‘é€é˜²ç©ºæŠ¥æ–‡
      setTimeout(() => {
        ElMessage.info('å·²è‡ªåŠ¨å‘é€é˜²ç©ºæŠ¥æ–‡ç»™æ— äººæœº');
        fireStatus.value = 'é˜²ç©ºæŠ¥æ–‡å·²å‘é€';
      }, 1000);
      
      // é‡ç½®çŠ¶æ€
      setTimeout(() => {
        fireStatus.value = 'å¾…å‘å°„';
        // æ¨¡æ‹Ÿç›®æ ‡å˜åŒ–
        targetDroneId.value = `UAV-${String(Math.floor(Math.random() * 999) + 1).padStart(3, '0')}`;
        // æ¸…ç©ºè¾“å…¥æ¡†ï¼Œå‡†å¤‡ä¸‹æ¬¡æ“ä½œ
        // weaponName.value = '';
        // targetName.value = '';
      }, 3000);
      
    } else {
      ElMessage.error(`å‘é€å¤±è´¥: ${result.error}`);
      fireStatus.value = 'å‘é€å¤±è´¥';
      artilleryStatus.isLoaded = true; // æ¢å¤è£…å¡«çŠ¶æ€
    }
    
  } catch (error) {
    console.error('å‘å°„æ“ä½œå¤±è´¥:', error);
    ElMessage.error('å‘å°„æ“ä½œå¤±è´¥');
    fireStatus.value = 'æ“ä½œå¤±è´¥';
    artilleryStatus.isLoaded = true; // æ¢å¤è£…å¡«çŠ¶æ€
  }
  
  // TODO: å®é™…çš„å‘å°„é€»è¾‘å’Œé˜²ç©ºæŠ¥æ–‡å‘é€
};

// æ‰“å¼€æ–‡æ¡£
const openDocument = () => {
  ElMessage.info('æ‰“å¼€ä»»åŠ¡æ–‡æ¡£åŠŸèƒ½å¾…å®ç°');
  // TODO: å®ç°æ‰“å¼€Wordæ–‡æ¡£çš„åŠŸèƒ½
};
</script>

<style scoped>
.el-form-item {
  margin-bottom: 12px;
}
</style>
```

**Section sources**
- [src/renderer/views/pages/ArtilleryOperationPage.vue](file://src/renderer/views/pages/ArtilleryOperationPage.vue)

### ç»„æ’­ç›‘å¬é¡µé¢åˆ†æ
ç»„æ’­ç›‘å¬é¡µé¢è´Ÿè´£å±•ç¤ºæ¥æ”¶åˆ°çš„æ•°æ®åŒ…ä¿¡æ¯ã€‚ç»„æ’­ç›‘å¬é¡µé¢é€šè¿‡ `MulticastPage.vue` æ–‡ä»¶ä¸­çš„ `MulticastPage` ç»„ä»¶å®ç°ï¼Œä½¿ç”¨ Vue 3 å’Œ Element Plus æ„å»ºç”¨æˆ·ç•Œé¢ã€‚ç»„æ’­ç›‘å¬é¡µé¢é€šè¿‡ `preload.ts` æ–‡ä»¶ä¸­çš„ `contextBridge` è°ƒç”¨ä¸»è¿›ç¨‹çš„ IPC æ¥å£ï¼Œè·å–ç»„æ’­é…ç½®ã€çŠ¶æ€å’Œæ•°æ®åŒ…ä¿¡æ¯ã€‚

#### ç»„æ’­ç›‘å¬é¡µé¢ç»„ä»¶
```vue
<template>
  <div class="flex flex-col h-full p-4">
    <!-- é…ç½®åŒºåŸŸ -->
    <div class="bg-white rounded-lg shadow-md p-6 mb-4">
      <h2 class="text-xl font-semibold mb-4">ç»„æ’­é…ç½®</h2>
      <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
        <el-form-item label="ç»„æ’­åœ°å€">
          <el-input 
            v-model="config.address" 
            placeholder="239.255.43.21"
            :disabled="isListening"
          />
        </el-form-item>
        <el-form-item label="ç«¯å£">
          <el-input-number 
            v-model="config.port" 
            :min="1024" 
            :max="65535"
            placeholder="10086"
            :disabled="isListening"
            style="width: 100%"
          />
        </el-form-item>
        <el-form-item label="æ¥å£åœ°å€">
          <el-input 
            v-model="config.interfaceAddress" 
            placeholder="0.0.0.0"
            :disabled="isListening"
          />
        </el-form-item>
      </div>
      <div class="flex gap-2 mt-4">
        <el-button 
          type="primary" 
          @click="startListening"
          :loading="starting"
          :disabled="isListening"
        >
          å¼€å§‹ç›‘å¬
        </el-button>
        <el-button 
          type="danger" 
          @click="stopListening"
          :loading="stopping"
          :disabled="!isListening"
        >
          åœæ­¢ç›‘å¬
        </el-button>
        <el-button @click="clearPackets">æ¸…ç©ºæ•°æ®</el-button>
      </div>
    </div>

    <!-- çŠ¶æ€æ˜¾ç¤º -->
    <div class="bg-white rounded-lg shadow-md p-6 mb-4">
      <h2 class="text-xl font-semibold mb-4">ç›‘å¬çŠ¶æ€</h2>
      <div class="grid grid-cols-1 md:grid-cols-6 gap-4">
        <div class="text-center">
          <div class="text-2xl font-bold" :class="isListening ? 'text-green-600' : 'text-red-600'">
            {{ isListening ? 'ç›‘å¬ä¸­' : 'å·²åœæ­¢' }}
          </div>
          <div class="text-sm text-gray-500">çŠ¶æ€</div>
        </div>
        <div class="text-center">
          <div class="text-2xl font-bold text-blue-600">{{ status.address }}</div>
          <div class="text-sm text-gray-500">ç»„æ’­åœ°å€</div>
        </div>
        <div class="text-center">
          <div class="text-2xl font-bold text-blue-600">{{ status.port }}</div>
          <div class="text-sm text-gray-500">ç«¯å£</div>
        </div>
        <div class="text-center">
          <div class="text-2xl font-bold text-purple-600">{{ packets.length }}</div>
          <div class="text-sm text-gray-500">æ€»æ•°æ®åŒ…</div>
        </div>
        <div class="text-center">
          <div class="text-2xl font-bold text-green-600">{{ parsedPacketsCount }}</div>
          <div class="text-sm text-gray-500">å·²è§£æ</div>
        </div>
        <div class="text-center">
          <div class="text-2xl font-bold text-orange-600">{{ platformStatusCount }}</div>
          <div class="text-sm text-gray-500">å¹³å°çŠ¶æ€</div>
        </div>
      </div>
    </div>

    <!-- æ•°æ®åŒ…åˆ—è¡¨ -->
    <div class="bg-white rounded-lg shadow-md p-6 flex-1 overflow-hidden">
      <div class="flex justify-between items-center mb-4">
        <h2 class="text-xl font-semibold">æ¥æ”¶åˆ°çš„æ•°æ®åŒ…</h2>
        <div class="flex gap-2">
          <el-switch 
            v-model="autoScroll" 
            active-text="è‡ªåŠ¨æ»šåŠ¨"
            inactive-text="æ‰‹åŠ¨æ»šåŠ¨"
          />
          <el-button size="small" @click="exportPackets">å¯¼å‡ºæ•°æ®</el-button>
        </div>
      </div>
      
      <div 
        ref="packetContainer"
        class="border rounded-lg p-4 h-full overflow-y-auto bg-gray-50"
        style="max-height: 400px;"
      >
        <div v-if="packets.length === 0" class="text-center text-gray-500 py-8">
          æš‚æ— æ•°æ®åŒ…
        </div>
        <div 
          v-for="(packet, index) in packets" 
          :key="index"
          class="bg-white rounded-lg p-4 mb-3 shadow-sm border"
        >
          <div class="flex justify-between items-start mb-2">
            <div class="flex gap-4 text-sm text-gray-600">
              <span>æ—¶é—´: {{ formatTime(packet.timestamp) }}</span>
              <span>æ¥æº: {{ packet.source }}</span>
              <span>å¤§å°: {{ packet.size }} å­—èŠ‚</span>
            </div>
            <el-tag size="small" type="info">#{{ index + 1 }}</el-tag>
          </div>
          <div class="bg-gray-100 rounded p-3 font-mono text-sm overflow-x-auto">
            <div v-if="packet.parsedPacket" class="mb-4">
              <div class="text-green-600 font-semibold mb-2">âœ… è§£ææˆåŠŸ:</div>
              <div class="bg-white rounded p-2 mb-2">
                <div class="grid grid-cols-2 gap-2 text-xs">
                  <div><strong>åŒ…ç±»å‹:</strong> {{ packet.parsedPacket.packageTypeName }}</div>
                  <div><strong>ç±»å‹ç :</strong> 0x{{ packet.parsedPacket.packageType.toString(16).padStart(2, '0') }}</div>
                  <div><strong>åè®®ID:</strong> 0x{{ packet.parsedPacket.protocolID.toString(16).padStart(2, '0') }}</div>
                  <div><strong>æ•°æ®å¤§å°:</strong> {{ packet.parsedPacket.size }} å­—èŠ‚</div>
                </div>
              </div>
              
              <!-- å¹³å°çŠ¶æ€ç‰¹æ®Šæ˜¾ç¤º -->
              <div v-if="packet.parsedPacket.packageType === 0x29 && packet.parsedPacket.parsedData" class="bg-blue-50 rounded p-2 mb-2">
                <div class="text-blue-700 font-semibold text-xs mb-1">ğŸš å¹³å°çŠ¶æ€ä¿¡æ¯:</div>
                <div class="grid grid-cols-2 gap-2 text-xs">
                  <div><strong>å¹³å°æ•°é‡:</strong> {{ packet.parsedPacket.parsedData.platform.length }}</div>
                  <div v-if="packet.parsedPacket.parsedData.platform[0]">
                    <strong>å¹³å°ç±»å‹:</strong> {{ packet.parsedPacket.parsedData.platform[0].base.type }}
                  </div>
                  <div v-if="packet.parsedPacket.parsedData.platform[0]?.base?.location">
                    <strong>ç»åº¦:</strong> {{ packet.parsedPacket.parsedData.platform[0].base.location.longitude?.toFixed(6) }}Â°
                  </div>
                  <div v-if="packet.parsedPacket.parsedData.platform[0]?.base?.location">
                    <strong>çº¬åº¦:</strong> {{ packet.parsedPacket.parsedData.platform[0].base.location.latitude?.toFixed(6) }}Â°
                  </div>
                  <div v-if="packet.parsedPacket.parsedData.platform[0]?.base?.location" class="col-span-2">
                    <strong>é«˜åº¦:</strong> {{ packet.parsedPacket.parsedData.platform[0].base.location.altitude?.toFixed(1) }}m
                  </div>
                </div>
              </div>
              
              <!-- å¹³å°æ§åˆ¶å‘½ä»¤ç‰¹æ®Šæ˜¾ç¤º -->
              <div v-if="packet.parsedPacket.packageType === 0x2A && packet.parsedPacket.parsedData" class="bg-green-50 rounded p-2 mb-2">
                <div class="text-green-700 font-semibold text-xs mb-1">ğŸ¯ å¹³å°æ§åˆ¶å‘½ä»¤:</div>
                <div class="grid grid-cols-2 gap-2 text-xs">
                  <div><strong>å‘½ä»¤ID:</strong> {{ packet.parsedPacket.parsedData.commandID }}</div>
                  <div><strong>å¹³å°åç§°:</strong> {{ packet.parsedPacket.parsedData.platformName }}</div>
                  <div><strong>å¹³å°ç±»å‹:</strong> {{ packet.parsedPacket.parsedData.platformType }}</div>
                  <div><strong>å‘½ä»¤:</strong> {{ getCommandName(packet.parsedPacket.parsedData.command) }}</div>
                  <div v-if="packet.parsedPacket.parsedData.fireParam" class="col-span-2">
                    <strong>æ­¦å™¨:</strong> {{ packet.parsedPacket.parsedData.fireParam.weaponName }}
                  </div>
                  <div v-if="packet.parsedPacket.parsedData.fireParam" class="col-span-2">
                    <strong>ç›®æ ‡:</strong> {{ packet.parsedPacket.parsedData.fireParam.targetName }}
                  </div>
                </div>
              </div>
              
              <div class="text-xs">
                <div class="text-gray-600 font-semibold mb-1">å®Œæ•´è§£ææ•°æ®:</div>
                <pre class="bg-white rounded p-2 text-xs overflow-x-auto">{{ JSON.stringify(packet.parsedPacket.parsedData, null, 2) }}</pre>
              </div>
            </div>
            
            <div v-else class="mb-4">
              <div class="text-red-600 font-semibold mb-2">âŒ æœªè§£æ (æ˜¾ç¤ºåŸå§‹æ•°æ®):</div>
              <div class="bg-yellow-50 rounded p-2 text-xs">
                <div><strong>å¯èƒ½åŸå› :</strong> åŒ…æ ¼å¼ä¸åŒ¹é…ã€protobufå®šä¹‰æœªåŠ è½½æˆ–æ•°æ®æŸå</div>
              </div>
            </div>
            
            <div class="mt-2">
              <div class="text-gray-600 font-semibold mb-1">åŸå§‹åå…­è¿›åˆ¶æ•°æ®:</div>
              <div class="bg-white rounded p-2">
                <pre class="text-xs break-all">{{ toHex(packet.data) }}</pre>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, reactive, computed, onMounted, onUnmounted, nextTick, watch } from 'vue';
import { ElMessage } from 'element-plus';

interface MulticastPacket {
  timestamp: number;
  source: string;
  data: Buffer;
  dataString: string;
  size: number;
  parsedPacket?: {
    timestamp: number;
    source: string;
    packageType: number;
    packageTypeName: string;
    parsedData: any;
    rawData: Buffer;
    size: number;
  };
}

interface MulticastStatus {
  isListening: boolean;
  address: string;
  port: number;
}

const isListening = ref(false);
const starting = ref(false);
const stopping = ref(false);
const autoScroll = ref(true);
const packets = ref<MulticastPacket[]>([]);
const packetContainer = ref<HTMLElement>();

const status = reactive<MulticastStatus>({
  isListening: false,
  address: '',
  port: 0
});

const config = reactive({
  address: '239.255.43.21',
  port: 10086,
  interfaceAddress: '0.0.0.0'
});

// è®¡ç®—å±æ€§
const parsedPacketsCount = computed(() => {
  return packets.value.filter(p => p.parsedPacket).length;
});

const platformStatusCount = computed(() => {
  return packets.value.filter(p => p.parsedPacket?.packageType === 0x29).length;
});

// æ ¼å¼åŒ–æ—¶é—´
const formatTime = (timestamp: number) => {
  return new Date(timestamp).toLocaleString('zh-CN');
};

// åŸå§‹æ•°æ®è½¬åå…­è¿›åˆ¶
function toHex(buffer: Buffer | Uint8Array | number[]): string {
  if (!buffer) return '';
  return Array.from(buffer)
    .map(b => b.toString(16).padStart(2, '0'))
    .join(' ');
}

// è·å–å‘½ä»¤åç§°
const getCommandName = (command: number): string => {
  const commands: Record<number, string> = {
    9: 'ç«ç‚®è£…å¡«',
    10: 'ç«ç‚®å‘å°„'
  };
  return commands[command] || `æœªçŸ¥å‘½ä»¤(${command})`;
};

// å¼€å§‹ç›‘å¬
const startListening = async () => {
  starting.value = true;
  try {
    const result = await window.electronAPI.multicast.updateConfig(
      config.address,
      config.port,
      config.interfaceAddress
    );
    
    if (result.success) {
      const startResult = await window.electronAPI.multicast.start();
      if (startResult.success) {
        ElMessage.success('ç»„æ’­ç›‘å¬å·²å¯åŠ¨');
        await updateStatus();
      } else {
        ElMessage.error(`å¯åŠ¨å¤±è´¥: ${startResult.error}`);
      }
    } else {
      ElMessage.error(`é…ç½®æ›´æ–°å¤±è´¥: ${result.error}`);
    }
  } catch (error) {
    ElMessage.error(`å¯åŠ¨ç›‘å¬å¤±è´¥: ${error}`);
  } finally {
    starting.value = false;
  }
};

// åœæ­¢ç›‘å¬
const stopListening = async () => {
  stopping.value = true;
  try {
    const result = await window.electronAPI.multicast.stop();
    if (result.success) {
      ElMessage.success('ç»„æ’­ç›‘å¬å·²åœæ­¢');
      await updateStatus();
    } else {
      ElMessage.error(`åœæ­¢å¤±è´¥: ${result.error}`);
    }
  } catch (error) {
    ElMessage.error(`åœæ­¢ç›‘å¬å¤±è´¥: ${error}`);
  } finally {
    stopping.value = false;
  }
};

// åŠ è½½é…ç½®
const loadConfig = async () => {
  try {
    const envConfig = await window.electronAPI.multicast.getConfig();
    Object.assign(config, envConfig);
  } catch (error) {
    console.error('åŠ è½½é…ç½®å¤±è´¥:', error);
  }
};

// æ›´æ–°çŠ¶æ€
const updateStatus = async () => {
  try {
    const currentStatus = await window.electronAPI.multicast.getStatus();
    Object.assign(status, currentStatus);
    isListening.value = currentStatus.isListening;
  } catch (error) {
    console.error('è·å–çŠ¶æ€å¤±è´¥:', error);
  }
};

// æ¸…ç©ºæ•°æ®åŒ…
const clearPackets = () => {
  packets.value = [];
};

// å¯¼å‡ºæ•°æ®åŒ…
const exportPackets = async () => {
  if (packets.value.length === 0) {
    ElMessage.warning('æ²¡æœ‰æ•°æ®å¯å¯¼å‡º');
    return;
  }

  try {
    const filePath = await window.electronAPI.export.showSaveDialog({
      title: 'å¯¼å‡ºç»„æ’­æ•°æ®',
      defaultFileName: `multicast_packets_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`,
      filters: [
        { name: 'JSON Files', extensions: ['json'] },
        { name: 'All Files', extensions: ['*'] }
      ]
    });

    if (filePath) {
      const result = await window.electronAPI.export.exportFile(filePath, {
        config: config,
        status: status,
        packets: packets.value,
        exportTime: new Date().toISOString()
      });

      if (result.success) {
        ElMessage.success('æ•°æ®å¯¼å‡ºæˆåŠŸ');
      } else {
        ElMessage.error(`å¯¼å‡ºå¤±è´¥: ${result.error}`);
      }
    }
  } catch (error) {
    ElMessage.error(`å¯¼å‡ºå¤±è´¥: ${error}`);
  }
};

// è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
const scrollToBottom = async () => {
  if (autoScroll.value && packetContainer.value) {
    await nextTick();
    packetContainer.value.scrollTop = packetContainer.value.scrollHeight;
  }
};

// ç›‘å¬æ•°æ®åŒ…
const handlePacket = (packet: MulticastPacket) => {
  packets.value.push(packet);
  scrollToBottom();
};

// ç›‘å¬é”™è¯¯
const handleError = (error: string) => {
  ElMessage.error(`ç»„æ’­é”™è¯¯: ${error}`);
};

// ç›‘å¬æ•°æ®åŒ…å˜åŒ–ï¼Œè‡ªåŠ¨æ»šåŠ¨
watch(packets, () => {
  scrollToBottom();
}, { deep: true });

onMounted(async () => {
  // è®¾ç½®äº‹ä»¶ç›‘å¬
  window.electronAPI.multicast.onPacket(handlePacket);
  window.electronAPI.multicast.onError(handleError);
  
  // è·å–åˆå§‹é…ç½®
  await loadConfig();
  
  // è·å–åˆå§‹çŠ¶æ€
  await updateStatus();
});

onUnmounted(() => {
  // æ¸…ç†äº‹ä»¶ç›‘å¬
  window.electronAPI.multicast.removeAllListeners('multicast:packet');
  window.electronAPI.multicast.removeAllListeners('multicast:error');
});
</script>

<style scoped>
.el-form-item {
  margin-bottom: 0;
}
</style> 
```

**Section sources**
- [src/renderer/views/pages/MulticastPage.vue](file://src/renderer/views/pages/MulticastPage.vue)

## ä¾èµ–åˆ†æ
afs-opEnd é¡¹ç›®ä¾èµ–å¤šä¸ªå¤–éƒ¨åº“å’Œæ¨¡å—ï¼ŒåŒ…æ‹¬ Electronã€Vue 3ã€TypeScriptã€better-sqlite3 å’Œ protobufjsã€‚è¿™äº›ä¾èµ–é¡¹é€šè¿‡ `package.json` æ–‡ä»¶ç®¡ç†ï¼Œå¹¶é€šè¿‡ `npm install` å‘½ä»¤å®‰è£…ã€‚é¡¹ç›®è¿˜ä¾èµ–äº Node.js çš„ `dgram` æ¨¡å—å’Œ `fs` æ¨¡å—ï¼Œç”¨äºå¤„ç† UDP ç»„æ’­å’Œæ–‡ä»¶æ“ä½œã€‚

```mermaid
graph TD
A[afs-opEnd] --> B[Electron]
A --> C[Vue 3]
A --> D[TypeScript]
A --> E[better-sqlite3]
A --> F[protobufjs]
B --> G[Node.js]
G --> H[dgram]
G --> I[fs]
```

**Diagram sources**
- [package.json](file://package.json)
- [src/main/main.ts](file://src/main/main.ts)
- [src/main/services/multicast.service.ts](file://src/main/services/multicast.service.ts)
- [src/main/database/db.service.ts](file://src/main/database/db.service.ts)
- [src/main/services/protobuf-parser.service.ts](file://src/main/services/protobuf-parser.service.ts)
- [src/main/services/multicast-sender.service.ts](file://src/main/services/multicast-sender.service.ts)

**Section sources**
- [package.json](file://package.json)
- [src/main/main.ts](file://src/main/main.ts)
- [src/main/services/multicast.service.ts](file://src/main/services/multicast.service.ts)
- [src/main/database/db.service.ts](file://src/main/database/db.service.ts)
- [src/main/services/protobuf-parser.service.ts](file://src/main/services/protobuf-parser.service.ts)
- [src/main/services/multicast-sender.service.ts](file://src/main/services/multicast-sender.service.ts)

## æ€§èƒ½è€ƒé‡
afs-opEnd é¡¹ç›®åœ¨è®¾è®¡æ—¶è€ƒè™‘äº†æ€§èƒ½ä¼˜åŒ–ï¼Œç‰¹åˆ«æ˜¯åœ¨æ•°æ®å¤„ç†å’Œç”¨æˆ·ç•Œé¢å“åº”æ–¹é¢ã€‚ä¸»è¿›ç¨‹é€šè¿‡ `better-sqlite3` åº“å®ç°é«˜æ•ˆçš„æ•°æ®æŒä¹…åŒ–å­˜å‚¨ï¼Œæ¸²æŸ“è¿›ç¨‹é€šè¿‡ Vue 3 çš„å“åº”å¼ç³»ç»Ÿå®ç°é«˜æ•ˆçš„ç”¨æˆ·ç•Œé¢æ›´æ–°ã€‚ç»„æ’­æœåŠ¡é€šè¿‡ `dgram` æ¨¡å—å®ç°é«˜æ•ˆçš„ UDP ç»„æ’­ç›‘å¬ï¼ŒProtobuf è§£ææœåŠ¡é€šè¿‡ `protobufjs` åº“å®ç°é«˜æ•ˆçš„ Protobuf æ•°æ®è§£æã€‚

## æ•…éšœæ’é™¤æŒ‡å—
### å¸¸è§é—®é¢˜
1. **æ— æ³•å¯åŠ¨ç›‘å¬**
   - æ£€æŸ¥ç«¯å£æ˜¯å¦è¢«å ç”¨
   - ç¡®è®¤æœ‰è¶³å¤Ÿçš„æƒé™
   - éªŒè¯ç½‘ç»œæ¥å£é…ç½®

2. **æ¥æ”¶ä¸åˆ°æ•°æ®**
   - ç¡®è®¤å‘é€æ–¹ä½¿ç”¨æ­£ç¡®çš„ç»„æ’­åœ°å€å’Œç«¯å£
   - æ£€æŸ¥ç½‘ç»œé˜²ç«å¢™è®¾ç½®
   - éªŒè¯ç½‘ç»œæ”¯æŒç»„æ’­

3. **æ•°æ®ä¹±ç **
   - æ£€æŸ¥æ•°æ®ç¼–ç æ ¼å¼
   - ç¡®è®¤å‘é€æ–¹ä½¿ç”¨ UTF-8 ç¼–ç 

4. **æ— æ³•å‘é€æ§åˆ¶å‘½ä»¤**
   - æ£€æŸ¥ç»„æ’­å‘é€æœåŠ¡æ˜¯å¦å·²åˆå§‹åŒ–
   - ç¡®è®¤protobufå®šä¹‰æ–‡ä»¶å·²æ­£ç¡®åŠ è½½
   - éªŒè¯ç½‘ç»œé…ç½®æ˜¯å¦å…è®¸å‘é€ç»„æ’­æ•°æ®

5. **Protobufå®šä¹‰æ–‡ä»¶æœªåŠ è½½**
   - æ£€æŸ¥protobufæ–‡ä»¶è·¯å¾„æ˜¯å¦æ­£ç¡®
   - ç¡®è®¤å¼€å‘ç¯å¢ƒå’Œç”Ÿäº§ç¯å¢ƒçš„è·¯å¾„é…ç½®
   - éªŒè¯æ–‡ä»¶æ˜¯å¦å­˜åœ¨ä¸”å¯è¯»

### è°ƒè¯•æ–¹æ³•
1. æŸ¥çœ‹ä¸»è¿›ç¨‹æ§åˆ¶å°è¾“å‡º
2. æ£€æŸ¥ç½‘ç»œè¿æ¥çŠ¶æ€
3. ä½¿ç”¨ç½‘ç»œæŠ“åŒ…å·¥å…·éªŒè¯æ•°æ®åŒ…
4. æ£€æŸ¥protobufè§£ææ—¥å¿—
5. éªŒè¯IPCé€šä¿¡æ˜¯å¦æ­£å¸¸

**Section sources**
- [MULTICAST_README.md](file://MULTICAST_README.md)
- [PLATFORM_CMD_README.md](file://PLATFORM_CMD_README.md)
- [PLATFORM_STATUS_README.md](file://PLATFORM_STATUS_README.md)

## ç»“è®º
afs-opEnd æ˜¯ä¸€ä¸ªåŠŸèƒ½å¼ºå¤§çš„æ— äººæœºé€šä¿¡æ¨¡æ‹Ÿä¸ç›‘æ§æ¡Œé¢åº”ç”¨ï¼Œé€šè¿‡é›†æˆ Electronã€Vue 3ã€TypeScriptã€better-sqlite3 å’Œ protobufjs ç­‰æŠ€æœ¯æ ˆï¼Œå®ç°äº†é«˜æ•ˆçš„ç»„æ’­ç›‘å¬ã€Protobuf è§£æå’Œæ•°æ®æŒä¹…åŒ–å­˜å‚¨ã€‚é¡¹ç›®é‡‡ç”¨ä¸»è¿›ç¨‹ä¸æ¸²æŸ“è¿›ç¨‹åˆ†ç¦»çš„è®¾è®¡ï¼Œç¡®ä¿äº†ç³»ç»Ÿçš„ç¨³å®šæ€§å’Œå¯ç»´æŠ¤æ€§ã€‚é€šè¿‡è¯¦ç»†çš„æ–‡æ¡£å’Œç¤ºä¾‹ä»£ç ï¼Œå¼€å‘è€…å¯ä»¥å¿«é€Ÿä¸Šæ‰‹å¹¶æ‰©å±•åº”ç”¨åŠŸèƒ½ã€‚

æœ€æ–°ç‰ˆæœ¬å¢åŠ äº†å¯¹å¹³å°çŠ¶æ€ç›‘æ§å’Œç«ç‚®æ§åˆ¶å‘½ä»¤çš„æ”¯æŒï¼Œä½¿å¾—ç³»ç»Ÿä¸ä»…èƒ½å¤Ÿæ¥æ”¶å’Œç›‘æ§æ— äººæœºé€šä¿¡æ•°æ®ï¼Œè¿˜èƒ½å¤Ÿä¸»åŠ¨å‘é€æ§åˆ¶æŒ‡ä»¤ã€‚å¹³å°çŠ¶æ€åŠŸèƒ½æä¾›äº†è¯¦ç»†çš„å¹³å°ä¿¡æ¯ï¼ŒåŒ…æ‹¬ä½ç½®ã€çŠ¶æ€ã€è®¾å¤‡é…ç½®ç­‰ï¼Œä¸ºæ— äººæœºå­¦ä¹ åœºæ™¯æä¾›äº†æ›´å…¨é¢çš„æ€åŠ¿æ„ŸçŸ¥èƒ½åŠ›ã€‚ç«ç‚®æ§åˆ¶å‘½ä»¤åŠŸèƒ½åˆ™å®ç°äº†ä»ç«ç‚®æ“ä½œé¡µé¢å‘é€æ§åˆ¶æŒ‡ä»¤çš„èƒ½åŠ›ï¼Œæ”¯æŒç”¨æˆ·è¾“å…¥æ­¦å™¨åç§°å’Œç›®æ ‡åç§°ï¼Œå¢å¼ºäº†ç³»ç»Ÿçš„äº¤äº’æ€§å’Œå®ç”¨æ€§ã€‚è¿™äº›æ–°åŠŸèƒ½çš„æ·»åŠ ä½¿å¾—afs-opEndæˆä¸ºä¸€ä¸ªæ›´åŠ å®Œæ•´å’Œå®ç”¨çš„æ— äººæœºé€šä¿¡æ¨¡æ‹Ÿä¸ç›‘æ§å·¥å…·ã€‚